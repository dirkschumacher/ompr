[{"path":"https://dirkschumacher.github.io/ompr/CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, pledge respect people contribute reporting issues, posting feature requests, updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience, gender, gender identity expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion. Examples unacceptable behavior participants include use sexual language imagery, derogatory comments personal attacks, trolling, public private harassment, insults, unprofessional conduct. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct. Project maintainers follow Code Conduct may removed project team. Instances abusive, harassing, otherwise unacceptable behavior may reported opening issue contacting one project maintainers. Code Conduct adapted Contributor Covenant (http:contributor-covenant.org), version 1.0.0, available http://contributor-covenant.org/version/1/0/0/","code":""},{"path":"https://dirkschumacher.github.io/ompr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 OMPR authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"a-milp-model","dir":"Articles","previous_headings":"","what":"A MILP Model","title":"Modelling techniques in OMPR using MILPModel","text":"can think MIP Model big constraint maxtrix set vectors. can also think set decision variables, objective function number constraints equations/inequalities. ompr implements latter approach. example, Wikipedia describes Knapsack problem like : \\[ \\begin{equation*} \\begin{array}{ll@{}ll} \\text{max}  & \\displaystyle\\sum\\limits_{=1}^{n} v_{}x_{} & &\\\\ \\text{subject }& \\displaystyle\\sum\\limits_{=1}^{n}   w_{}x_{} \\leq W,  & &\\\\                  &                                                x_{} \\\\{0,1\\}, &=1 ,\\ldots, n& \\end{array} \\end{equation*} \\] ompr equivalent: overall idea use modern R idioms construct models like one readable possible directly R. ompr heavy lifting transforms everything matrices/vectors pass favorite solver.","code":"n <- 10; W <- 2 v <- runif(n);w <- runif(n) model <- MILPModel() %>%   add_variable(x[i], i = 1:n, type = \"binary\") %>%   set_objective(sum_expr(colwise(v[i]) * x[i], i = 1:n)) %>%   add_constraint(sum_expr(colwise(w[i]) * x[i], i = 1:n) <= W)"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"vectorized-semantics","dir":"Articles","previous_headings":"","what":"Vectorized semantics","title":"Modelling techniques in OMPR using MILPModel","text":"ompr supppots different backends. backend empty model add variables, constraints etc. Currently two backends exist: MIPModel MILPModel. vignette describes latter first become deprecated. Compared old MIPModel backend, MILPModel vectorized semantics. Meaning model variables accept expect vectors. enables speedup factor 1000 . details can found end document.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"pipes","dir":"Articles","previous_headings":"","what":"Pipes","title":"Modelling techniques in OMPR using MILPModel","text":"function ompr creates immutable copies models. addition function interface designed work magrittr pipes. always start empty model add components .","code":"MIPModel() %>%   add_variable(x) %>%   set_objective(x) %>%   add_constraint(x <= 1) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 1  ##   Integer: 0  ##   Binary: 0  ## Model sense: maximize  ## Constraints: 1"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"variable-types","dir":"Articles","previous_headings":"","what":"Variable types","title":"Modelling techniques in OMPR using MILPModel","text":"Variables can type continuous, integer binary.","code":"MIPModel() %>%   add_variable(x, type = \"integer\") %>%   add_variable(y, type = \"continuous\") %>%   add_variable(z, type = \"binary\") ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 1  ##   Integer: 1  ##   Binary: 1  ## No objective function.  ## Constraints: 0"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"variable-bounds","dir":"Articles","previous_headings":"","what":"Variable bounds","title":"Modelling techniques in OMPR using MILPModel","text":"Variables can lower upper bounds.","code":"MIPModel() %>%    add_variable(x, lb = 10) %>%    add_variable(y, lb = 5, ub = 10) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 2  ##   Integer: 0  ##   Binary: 0  ## No objective function.  ## Constraints: 0"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"indexed-variables","dir":"Articles","previous_headings":"","what":"Indexed variables","title":"Modelling techniques in OMPR using MILPModel","text":"Often develop complex model work indexed variables. important concept ompr supports.","code":"MILPModel() %>%    add_variable(x[i], i = 1:10) %>%  # creates 10 decision variables   set_objective(x[5]) %>%    add_constraint(x[5] <= 10) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 10  ##   Integer: 0  ##   Binary: 0  ## Model sense: maximize  ## Constraints: 1"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"summation-over-variables","dir":"Articles","previous_headings":"","what":"Summation over variables","title":"Modelling techniques in OMPR using MILPModel","text":"indexed variables often want sum subset variables. following code creates model three decision variables \\(x_1\\), \\(x_2\\), \\(x_3\\). objective function \\(\\sum_i x_i\\) one constraint \\(\\sum_i x_i \\leq 10\\).","code":"MILPModel() %>%    add_variable(x[i], i = 1:3) %>%    set_objective(sum_expr(x[i], i = 1:3)) %>%    add_constraint(sum_expr(x[i], i = 1:3) <= 10) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 3  ##   Integer: 0  ##   Binary: 0  ## Model sense: maximize  ## Constraints: 1"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"quantifiers","dir":"Articles","previous_headings":"","what":"Quantifiers","title":"Modelling techniques in OMPR using MILPModel","text":"add_variable, add_constraint, set_bounds, sum_expr support common quantifier interface also supports filter expression. complex example show means.","code":"MILPModel() %>%    # Create x_{i, j} variables for all combinations of i and j where   # i = 1:10 and j = 1:10.   add_variable(x[i, j], type = \"binary\", i = 1:10, j = 1:10) %>%       # add a y_i variable for all i between 1 and 10 with i mod 2 = 0   add_variable(y[i], type = \"binary\", i = 1:10, i %% 2 == 0) %>%       # we maximize all x_{i,j} where i = j + 1   set_objective(sum_expr(x[i, j], i = 1:10, j = 1:10, i == j + 1)) %>%       # for each i between 1 and 10 with i mod 2 = 0   # we add a constraint \\sum_j x_{i,j}   add_constraint(sum_expr(x[i, j], j = 1:10) <= 1, i = 1:10, i %% 2 == 0) %>%       # of course you can leave out filters or add more than 1   add_constraint(sum_expr(x[i, j], j = 1:10) <= 2, i = 1:10) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 0  ##   Integer: 0  ##   Binary: 105  ## Model sense: maximize  ## Constraints: 15"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"special-bounds-on-a-subset-of-variables","dir":"Articles","previous_headings":"","what":"Special bounds on a subset of variables","title":"Modelling techniques in OMPR using MILPModel","text":"Imagine want model matching problem single binary decision variable \\(x_{,j}\\) \\(1\\) iff object \\(\\) matched object \\(j\\). One constraint allow matches \\(\\neq j\\). can modelled constraint selectively changing bounds variables. latter approach can used solvers improve solution process.","code":"MILPModel() %>%    add_variable(x[i, j], i = 1:10, j = 1:10,                 type = \"integer\", lb = 0, ub = 1) %>%    set_objective(sum_expr(x[i, j], i = 1:10, j = 1:10)) %>%    add_constraint(x[i, i] == 0, i = 1:10) %>%        # this sets the ub to 0 without adding new constraints   set_bounds(x[i, i], ub = 0, i = 1:10) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 0  ##   Integer: 100  ##   Binary: 0  ## Model sense: maximize  ## Constraints: 10"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"external-model-parameters","dir":"Articles","previous_headings":"","what":"External model parameters","title":"Modelling techniques in OMPR using MILPModel","text":"course need external parameters models. can reuse variable defined R environment within MIP Model.","code":"n <- 5 # number of our variables costs <- rpois(n, lambda = 3) # a cost vector max_elements <- 3 MILPModel() %>%    add_variable(x[i], type = \"binary\", i = 1:n) %>%    set_objective(sum_expr(colwise(costs[i]) * x[i], i = 1:n)) %>%    add_constraint(sum_expr(x[i], i = 1:n) <= max_elements) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 0  ##   Integer: 0  ##   Binary: 5  ## Model sense: maximize  ## Constraints: 1"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"extract-model-solutions","dir":"Articles","previous_headings":"","what":"Extract model solutions","title":"Modelling techniques in OMPR using MILPModel","text":"model, pass solver get back solutions. main interface extract variable values solution function get_solution. returns data.frame indexed variable thus makes easy subsequently use value. use ROI GLPK solve . can also fix certain indexes.","code":"library(ROI) ## ROI: R Optimization Infrastructure ## Registered solver plugins: nlminb, glpk. ## Default solver: auto. library(ROI.plugin.glpk) library(ompr.roi) set.seed(1) n <- 5 weights <- matrix(rpois(n * n, 5), ncol = n, nrow = n) # construct a function that is vectorized w <- function(i, j) {   vapply(seq_along(i), function(k) weights[i[k], j[k]], numeric(1L)) } result <- MILPModel() %>%    add_variable(x[i, j], i = 1:n, j = 1:n, type = \"binary\") %>%    set_objective(sum_expr(colwise(w(i, j)) * x[i, j], i = 1:n, j = 1:n)) %>%    add_constraint(sum_expr(x[i, j], j = 1:n) == 1, i = 1:n) %>%    solve_model(with_ROI(\"glpk\", verbose = TRUE)) ## <SOLVER MSG>  ---- ## GLPK Simplex Optimizer, v4.65 ## 5 rows, 25 columns, 25 non-zeros ##       0: obj =  -0.000000000e+00 inf =   5.000e+00 (5) ##       5: obj =   2.400000000e+01 inf =   0.000e+00 (0) ## *    14: obj =   4.400000000e+01 inf =   0.000e+00 (0) ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.65 ## 5 rows, 25 columns, 25 non-zeros ## 25 integer variables, all of which are binary ## Integer optimization begins... ## Long-step dual simplex will be used ## +    14: mip =     not found yet <=              +inf        (1; 0) ## +    14: >>>>>   4.400000000e+01 <=   4.400000000e+01   0.0% (1; 0) ## +    14: mip =   4.400000000e+01 <=     tree is empty   0.0% (0; 1) ## INTEGER OPTIMAL SOLUTION FOUND ## <!SOLVER MSG> ---- get_solution(result, x[i, j]) %>%    dplyr::filter(value == 1) ##   variable i j value ## 1        x 4 1     1 ## 2        x 2 2     1 ## 3        x 5 3     1 ## 4        x 3 4     1 ## 5        x 1 5     1 get_solution(result, x[2, j]) ##   variable j value ## 1        x 1     0 ## 2        x 2     1 ## 3        x 3     0 ## 4        x 4     0 ## 5        x 5     0"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"vectorized-semantics-revisited","dir":"Articles","previous_headings":"","what":"Vectorized semantics revisited","title":"Modelling techniques in OMPR using MILPModel","text":"variable accepts vectors. following code snippets show behaviour example: Instead passing index variables quantifiers, can also use vectors directly. element vector creates new row variable. two constraint groups equivalent. can also add vectors columnwise using function colwise as_colwise: Another example: Say want express matrix: vectorized semantics can following: support ompr function sum_expr","code":"n <- 10L MILPModel() %>%    add_variable(x[i, j], i = 1:n, j = 1:n) %>%    add_constraint(x[i, j] == 1, i = 1:n, j = 1:n, i == j) %>%    add_constraint(x[1:n, 1:n] == 1) # this this equivalent ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 100  ##   Integer: 0  ##   Binary: 0  ## No objective function.  ## Constraints: 20 MILPModel() %>%    add_variable(x[i, j], i = 1:n, j = 1:n) %>%    add_constraint(sum_expr(x[i, j], i = 1:n) == 1, j = 1:n) %>%    add_constraint(x[colwise(1:n), 1:n] == 1) # this this equivalent ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 100  ##   Integer: 0  ##   Binary: 0  ## No objective function.  ## Constraints: 20 x[1, 1] x[1, 1] + x[1, 2] x[1, 1] + x[1, 2] + x[1, 3] x[1, colwise(1, 1:2, 1:3)] MILPModel() %>%    add_variable(x[i, j], i = 1, j = 1:n) %>%    add_constraint(sum_expr(x[1, j], j = colwise(1, 1:2, 1:3)) == 1) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 10  ##   Integer: 0  ##   Binary: 0  ## No objective function.  ## Constraints: 3"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"coefficients-and-colwise","dir":"Articles","previous_headings":"Vectorized semantics revisited","what":"Coefficients and colwise","title":"Modelling techniques in OMPR using MILPModel","text":"colwise probably concept likely change future. However currently particular necessary set coefficients correctly within sum_expr. section shows couple examples use . model demonstrates use colwise set coefficients within sum_expr. Often, function taking variable indexes returning variable coefficients. long function returns colwise vector, everything works . difficulty figure length return value. Say constraint looks like : sum_fun return numeric vector wrapped colwise length row index (e.g. ) times length column index (e.g. j). case 3 * 2 = 6. template function look like : Note using multiple indexes, combinations indexes bound indexes.","code":"model <- MILPModel() %>%    add_variable(x[i, j], i = 1:2, j = 1:3) %>%       # this creates   # x[1, 1] + x[1, 2] + x[1, 3]   # x[2, 1] + x[2, 2] + x[2, 3]   add_constraint(sum_expr(x[i, j], j = 1:3) == 1, i = 1:2) %>%      # this creates   # 1 * x[1, 1] + 2 * x[1, 2] + 3 * x[1, 3]   # 1 * x[2, 1] + 2 * x[2, 2] + 3 * x[2, 3]   add_constraint(colwise(1:3) * sum_expr(x[i, j], j = 1:3) == 1, i = 1:2) %>%       # 1 * x[1, 1] + 2 * x[1, 2] + 3 * x[1, 3]   # 4 * x[2, 1] + 5 * x[2, 2] + 6 * x[2, 3]   add_constraint(sum_expr(colwise(1:6) * x[i, j], j = 1:3) == 1, i = 1:2) %>%       # 1 * x[1, 1] + 1 * x[1, 2] + 1 * x[1, 3]   # 2 * x[2, 1] + 2 * x[2, 2] + 2 * x[2, 3]   add_constraint(sum_expr(1:3 * x[i, j], j = 1:3) == 1, i = 1:2)   # the standard semantic is that numeric vectors have one coefficient   # for the entire row. Thus the first row gets multiplied by 1   # the second row by 2. And since there are only two rows, the third component   # gets ignored add_constraint(model, sum_expr(sum_fun(i, j) * x[i, j], j = 1:3) == 1, i = 1:2) sum_fun <- function(i, j) {   n_rows <- length(i)   n_col <- length(j)   colwise(vapply(seq_len(n_rows * n_col), function(x) {     x # 1, 2, 3, 4, 5, 6     # where 1, 2, 3 are for cols in the first row     # 4, 5, 6 are the cols in the second row and so on   }, numeric(1L))) }"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"adding-variables---vectorized","dir":"Articles","previous_headings":"Vectorized semantics revisited","what":"Adding variables - vectorized","title":"Modelling techniques in OMPR using MILPModel","text":"Sometimes, want control variable indexes bounds specifically. can either use filter expressions together set_bounds pass concrete variable indexes explicitly. following code equivalent: addition first block code, can also set bounds variables way: especially handy work large models lot index combinations invalid. example routing problem, define connection two cities binary variable x[, j] - lot ,j combinations usually invalid need enter model explicitly. Although lot solvers remove variables presolve.","code":"MILPModel() %>%    add_variable(x[i, j], i = 1:10, j = 1:10) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 100  ##   Integer: 0  ##   Binary: 0  ## No objective function.  ## Constraints: 0 grid <- expand.grid(i = 1:10, j = 1:10) MILPModel() %>%    add_variable(x[grid$i, grid$j]) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 100  ##   Integer: 0  ##   Binary: 0  ## No objective function.  ## Constraints: 0 MILPModel() %>%    add_variable(x[grid$i, grid$j], lb = grid$i * 10, ub = grid$i * 20) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 100  ##   Integer: 0  ##   Binary: 0  ## No objective function.  ## Constraints: 0"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-modelling.html","id":"feedback","dir":"Articles","previous_headings":"","what":"Feedback","title":"Modelling techniques in OMPR using MILPModel","text":"questions, ideas, comments? find mistake? Let’s discuss Github.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-problem-tsp.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The Traveling Salesman Problem","text":"vignette decribes solve TSP using ompr. Wikipedia gives following definition: travelling salesman problem (TSP) asks following question: Given list cities distances pair cities, shortest possible route visits city exactly returns origin city? Also Wikipedia article good starting point want know topic. basic definition set verticies (cities) set edges (connection cities). edge associated distance \\(d > 0\\). distance travel time, distance km monetary cost associated traveling one city another. Restrictions distances lead special cases problem. example metric-TSP requires triangle inequality holds triples edges. vignette construct TSP random points within Euclidean space.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-problem-tsp.html","id":"setting","dir":"Articles","previous_headings":"","what":"Setting","title":"The Traveling Salesman Problem","text":"First let us import librarys number cities: Boundary Euclidean space: random cities:  Now distance matrix","code":"library(knitr) library(dplyr) library(ggplot2) n <- 10 # from 0 to ... max_x <- 500 max_y <- 500 set.seed(123456) cities <- data.frame(id = 1:n, x = runif(n, max = max_x), y = runif(n, max = max_y)) ggplot(cities, aes(x, y)) +    geom_point() distance <- as.matrix(stats::dist(select(cities, x, y), diag = TRUE, upper = TRUE)) dist_fun <- function(i, j) {   vapply(seq_along(i), function(k) distance[i[k], j[k]], numeric(1L)) }"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-problem-tsp.html","id":"model-formulation","dir":"Articles","previous_headings":"","what":"Model formulation","title":"The Traveling Salesman Problem","text":"essential two prominent ways model TSP MILP. One formulate full model using Miller–Tucker–Zemlin (MTZ) formulation option use -called sub-tour elimination constraints .1 first formulation fairly compact (quadratic many constraints variables) suitable anymore n gets larger. second formulation exponential many constraints , can solve larger TSPs due better LP relaxation. idea latter approach add constraints model solution process soon solution found contains sub-tour. solution strategies like solvers usually offer callbacks let’s modify model branch--cut process - however currently supported ompr. Therefor use MTZ formulation solve fairly small TSP. Import ompr.","code":"library(ompr) model <- MILPModel() %>%   # we create a variable that is 1 iff we travel from city i to j   add_variable(x[i, j], i = 1:n, j = 1:n,                 type = \"integer\", lb = 0, ub = 1) %>%      # a helper variable for the MTZ formulation of the tsp   add_variable(u[i], i = 1:n, lb = 1, ub = n) %>%      # minimize travel distance   set_objective(sum_expr(colwise(dist_fun(i, j)) * x[i, j], i = 1:n, j = 1:n), \"min\") %>%      # you cannot go to the same city   set_bounds(x[i, i], ub = 0, i = 1:n) %>%      # leave each city   add_constraint(sum_expr(x[i, j], j = 1:n) == 1, i = 1:n) %>%   #   # visit each city   add_constraint(sum_expr(x[i, j], i = 1:n) == 1, j = 1:n) %>%      # ensure no subtours (arc constraints)   add_constraint(u[i] >= 2, i = 2:n) %>%    add_constraint(u[i] - u[j] + 1 <= (n - 1) * (1 - x[i, j]), i = 2:n, j = 2:n) model ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 10  ##   Integer: 100  ##   Binary: 0  ## Model sense: minimize  ## Constraints: 110"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-problem-tsp.html","id":"results","dir":"Articles","previous_headings":"","what":"Results","title":"The Traveling Salesman Problem","text":"model can now solved one many solver libraries. use GLPK. extract solution can use get_solution method return data.frame can used tidyverse packages. Now need link back indexes model actual cities. plot :","code":"library(ompr.roi) library(ROI.plugin.glpk) result <- solve_model(model, with_ROI(solver = \"glpk\", verbose = TRUE)) ## <SOLVER MSG>  ---- ## GLPK Simplex Optimizer, v4.65 ## 110 rows, 110 columns, 434 non-zeros ##       0: obj =   0.000000000e+00 inf =   2.900e+01 (29) ##      33: obj =   2.118421165e+03 inf =   5.551e-17 (0) ## *    62: obj =   1.450925576e+03 inf =   3.997e-15 (0) ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.65 ## 110 rows, 110 columns, 434 non-zeros ## 100 integer variables, 90 of which are binary ## Integer optimization begins... ## Long-step dual simplex will be used ## +    62: mip =     not found yet >=              -inf        (1; 0) ## +    81: >>>>>   1.471334313e+03 >=   1.450925576e+03   1.4% (4; 0) ## +   104: >>>>>   1.469860058e+03 >=   1.450925576e+03   1.3% (3; 1) ## +   120: mip =   1.469860058e+03 >=     tree is empty   0.0% (0; 7) ## INTEGER OPTIMAL SOLUTION FOUND ## <!SOLVER MSG> ---- solution <- get_solution(result, x[i, j]) %>%   filter(value > 0)  kable(head(solution, 3)) paths <- select(solution, i, j) %>%   rename(from = i, to = j) %>%   mutate(trip_id = row_number()) %>%   tidyr::gather(property, idx_val, from:to) %>%   mutate(idx_val = as.integer(idx_val)) %>%   inner_join(cities, by = c(\"idx_val\" = \"id\")) kable(head(arrange(paths, trip_id), 4)) ggplot(cities, aes(x, y)) +    geom_point() +    geom_line(data = paths, aes(group = trip_id)) +    ggtitle(paste0(\"Optimal route with cost: \", round(objective_value(result), 2)))"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-problem-tsp.html","id":"feedback","dir":"Articles","previous_headings":"","what":"Feedback","title":"The Traveling Salesman Problem","text":"questions, ideas, comments? find mistake? Let’s discuss Github.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-problem-warehouse-location.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The Warehouse Location Problem","text":"article look Warehouse Location Problem. Given set customers set locations build warehoses task decide build warehouses warehouses goods shipped customer. Thus two decisions need made : build warehouses assignment customers warehouses. simple setting also implies least one warehouse must built warehouse big enough serve customers. practical example: run logistics NGO want regularly distribute goods people need. identified set possible locations set distribution hubs, sure build . model might help. practice however might need incorporate additional constraints model.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-problem-warehouse-location.html","id":"the-mathematical-model","dir":"Articles","previous_headings":"","what":"The mathematical model","title":"The Warehouse Location Problem","text":"start set customers \\(C = \\{1 \\ldots n\\}\\) set possible warehouses \\(W = \\{1 \\ldots m\\}\\) built. addition cost function giving us transportation cost warehouse customer. Furthermore fixed cost associated warehouse built. basic version warehouse location problem adapted German Wikipedia page problem. \\[ \\begin{equation*} \\begin{array}{ll@{}ll} \\text{min}  & \\displaystyle\\sum\\limits_{=1}^{n}\\sum\\limits_{j=1}^{m}\\operatorname{transportcost}_{,j} \\cdot x_{, j} +  \\sum\\limits_{j=1}^{m}\\operatorname{fixedcost}_{j} \\cdot y_{j}& &\\\\ \\text{subject } & \\displaystyle\\sum\\limits_{j=1}^{m}   x_{, j} = 1  & =1 ,\\ldots, n&\\\\                   & \\displaystyle x_{, j} \\leq y_j,  & =1 ,\\ldots, n & j=1 ,\\ldots, m&\\\\                  &                                                x_{,j} \\\\{0,1\\} &=1 ,\\ldots, n, & j=1 ,\\ldots, m \\\\                  &                                                y_{j} \\\\{0,1\\} &j=1 ,\\ldots, m& \\end{array} \\end{equation*} \\]","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-problem-warehouse-location.html","id":"the-model-in-r","dir":"Articles","previous_headings":"","what":"The model in R","title":"The Warehouse Location Problem","text":"first thing need data. article simply generate artificial data. assume customers located grid euclidian distances: warehouses also randomly placed grid. fixed cost warehouses randomly generated well mean cost 10,000. fixed costs set warehouse following: Next step build functions takes customer warehouse returns transport cost. Now let’s plot everything. Black dots customers red dots possible warehouse locations.  model ompr looks like :","code":"set.seed(1234) grid_size <- 1000 n <- 100 customer_locations <- data.frame(   id = 1:n,   x = round(runif(n) * grid_size),   y = round(runif(n) * grid_size) ) m <- 20 warehouse_locations <- data.frame(   id = 1:m,   x = round(runif(m) * grid_size),   y = round(runif(m) * grid_size) ) fixedcost <- round(rnorm(m, mean = grid_size * 10, sd = grid_size * 5)) fixedcost ##  [1]  9043  6090 20291 13753 19121 10400  6843  2434  6820 11132 15068 11264 ## [13]  4140 13344  1749  8171  8419   259 14600  6886 transportcost <- function(i, j) {   customer <- customer_locations[i, ]   warehouse <- warehouse_locations[j, ]   round(sqrt((customer$x - warehouse$x)^2 + (customer$y - warehouse$y)^2)) } transportcost(1, 3) ## [1] 302 library(ggplot2) ## Warning in register(): Can't find generic `scale_type` in package ggplot2 to ## register S3 method. p <- ggplot(customer_locations, aes(x, y)) +   geom_point() +    geom_point(data = warehouse_locations, color = \"red\", alpha = 0.5, shape = 17) +   scale_x_continuous(limits = c(0, grid_size)) +   scale_y_continuous(limits = c(0, grid_size)) +   theme(axis.title = element_blank(),          axis.ticks = element_blank(),          axis.text = element_blank(), panel.grid = element_blank()) p + ggtitle(\"Warehouse location problem\",            \"Black dots are customers. Light red triangles show potential warehouse locations.\") library(ompr) library(magrittr) model <- MILPModel() %>%   # 1 iff i gets assigned to warehouse j   add_variable(x[i, j], i = 1:n, j = 1:m, type = \"binary\") %>%      # 1 iff warehouse j is built   add_variable(y[j], j = 1:m, type = \"binary\") %>%      # maximize the preferences   set_objective(sum_expr(colwise(transportcost(i, j)) * x[i, j], i = 1:n, j = 1:m) +                   sum_expr(colwise(fixedcost[j]) * y[j], j = 1:m), \"min\") %>%      # every customer needs to be assigned to a warehouse   add_constraint(sum_expr(x[i, j], j = 1:m) == 1, i = 1:n) %>%      # if a customer is assigned to a warehouse, then this warehouse must be built   add_constraint(x[i,j] <= y[j], i = 1:n, j = 1:m) model ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 0  ##   Integer: 0  ##   Binary: 2020  ## Model sense: minimize  ## Constraints: 2100"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-problem-warehouse-location.html","id":"solve-the-model","dir":"Articles","previous_headings":"","what":"Solve the model","title":"The Warehouse Location Problem","text":"use glpk solve model. solved problem objective value 33222. last step add assignments previous plot generated.  fixed costs setting 4 warehouses :","code":"library(ompr.roi) library(ROI.plugin.glpk) result <- solve_model(model, with_ROI(solver = \"glpk\", verbose = TRUE)) ## <SOLVER MSG>  ---- ## GLPK Simplex Optimizer, v4.65 ## 2100 rows, 2020 columns, 6000 non-zeros ##       0: obj =   0.000000000e+00 inf =   1.000e+02 (100) ##     101: obj =   5.223300000e+04 inf =   0.000e+00 (0) ## Perturbing LP to avoid stalling [398]... ## Removing LP perturbation [857]... ## *   857: obj =   3.322200000e+04 inf =   0.000e+00 (0) 3 ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.65 ## 2100 rows, 2020 columns, 6000 non-zeros ## 2020 integer variables, all of which are binary ## Integer optimization begins... ## Long-step dual simplex will be used ## +   857: mip =     not found yet >=              -inf        (1; 0) ## +   857: >>>>>   3.322200000e+04 >=   3.322200000e+04   0.0% (1; 0) ## +   857: mip =   3.322200000e+04 >=     tree is empty   0.0% (0; 1) ## INTEGER OPTIMAL SOLUTION FOUND ## <!SOLVER MSG> ---- suppressPackageStartupMessages(library(dplyr)) matching <- result %>%   get_solution(x[i,j]) %>%   filter(value > .9) %>%   select(i, j) plot_assignment <- matching %>%   inner_join(customer_locations, by = c(\"i\" = \"id\")) %>%   inner_join(warehouse_locations, by = c(\"j\" = \"id\")) customer_count <- matching %>% group_by(j) %>% summarise(n = n()) %>% rename(id = j) plot_warehouses <- warehouse_locations %>%   mutate(costs = fixedcost) %>%   inner_join(customer_count, by = \"id\") %>%   filter(id %in% unique(matching$j)) p +    geom_segment(data = plot_assignment, aes(x = x.y, y = y.y, xend = x.x, yend = y.x)) +    geom_point(data  = plot_warehouses, color = \"red\", size = 3, shape = 17) +   ggrepel::geom_label_repel(data  = plot_warehouses,                              aes(label = paste0(\"fixed costs:\", costs, \"; customers: \", n)),                              size = 2, nudge_y = 20) +    ggtitle(paste0(\"Cost optimal warehouse locations and customer assignment\"),           \"Big red triangles show warehouses that will be built, light red are unused warehouse locations.  Dots represent customers served by the respective warehouses.\") sum(fixedcost[unique(matching$j)]) ## [1] 11285"},{"path":"https://dirkschumacher.github.io/ompr/articles/milp-problem-warehouse-location.html","id":"feedback","dir":"Articles","previous_headings":"","what":"Feedback","title":"The Warehouse Location Problem","text":"questions, ideas, comments? find mistake? Let’s discuss Github.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/modelling.html","id":"a-mip-model","dir":"Articles","previous_headings":"","what":"A MIP Model","title":"Modelling techniques in OMPR","text":"can think MIP Model big constraint maxtrix set vectors. can also think set decision variables, objective function number constraints equations/inequalities. ompr implements latter approach. example, Wikipedia describes Knapsack problem like : \\[ \\begin{equation*} \\begin{array}{ll@{}ll} \\text{max}  & \\displaystyle\\sum\\limits_{=1}^{n} v_{}x_{} & &\\\\ \\text{subject }& \\displaystyle\\sum\\limits_{=1}^{n}   w_{}x_{} \\leq W,  & &\\\\                  &                                                x_{} \\\\{0,1\\}, &=1 ,\\ldots, n& \\end{array} \\end{equation*} \\] ompr equivalent: overall idea use modern R idioms construct models like one readable possible directly R. ompr heavy lifting transforms everything matrices/vectors pass favorite solver.","code":"n <- 10; W <- 2 v <- runif(n);w <- runif(n) model <- MIPModel() %>%    add_variable(x[i], i = 1:n, type = \"binary\") %>%    set_objective(sum_over(v[i] * x[i], i = 1:n)) %>%    add_constraint(sum_over(w[i] * x[i], i = 1:n) <= W)"},{"path":"https://dirkschumacher.github.io/ompr/articles/modelling.html","id":"pipes","dir":"Articles","previous_headings":"","what":"Pipes","title":"Modelling techniques in OMPR","text":"function ompr creates immutable copies models. addition function interface designed work magrittr pipes. always start empty model add components .","code":"MIPModel() %>%    add_variable(x) %>%    set_objective(x) %>%    add_constraint(x <= 1) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 1  ##   Integer: 0  ##   Binary: 0  ## Model sense: maximize  ## Constraints: 1"},{"path":"https://dirkschumacher.github.io/ompr/articles/modelling.html","id":"variable-types","dir":"Articles","previous_headings":"","what":"Variable types","title":"Modelling techniques in OMPR","text":"Variables can type continuous, integer binary.","code":"MIPModel() %>%    add_variable(x, type = \"integer\") %>%    add_variable(y, type = \"continuous\") %>%    add_variable(z, type = \"binary\") ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 1  ##   Integer: 1  ##   Binary: 1  ## No objective function.  ## Constraints: 0"},{"path":"https://dirkschumacher.github.io/ompr/articles/modelling.html","id":"variable-bounds","dir":"Articles","previous_headings":"","what":"Variable bounds","title":"Modelling techniques in OMPR","text":"Variables can lower upper bounds.","code":"MIPModel() %>%    add_variable(x, lb = 10) %>%    add_variable(y, lb = 5, ub = 10) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 2  ##   Integer: 0  ##   Binary: 0  ## No objective function.  ## Constraints: 0"},{"path":"https://dirkschumacher.github.io/ompr/articles/modelling.html","id":"indexed-variables","dir":"Articles","previous_headings":"","what":"Indexed variables","title":"Modelling techniques in OMPR","text":"Often develop complex model work indexed variables. important concept ompr supports.","code":"MIPModel() %>%    add_variable(x[i], i = 1:10) %>%  # creates 10 decision variables   set_objective(x[5]) %>%    add_constraint(x[5] <= 10) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 10  ##   Integer: 0  ##   Binary: 0  ## Model sense: maximize  ## Constraints: 1"},{"path":"https://dirkschumacher.github.io/ompr/articles/modelling.html","id":"summation-over-variables","dir":"Articles","previous_headings":"","what":"Summation over variables","title":"Modelling techniques in OMPR","text":"indexed variables often want sum subset variables. following code creates model three decision variables \\(x_1\\), \\(x_2\\), \\(x_3\\). objective function \\(\\sum_i x_i\\) one constraint \\(\\sum_i x_i \\leq 10\\).","code":"MIPModel() %>%    add_variable(x[i], i = 1:3) %>%    set_objective(sum_over(x[i], i = 1:3)) %>%    add_constraint(sum_over(x[i], i = 1:3) <= 10) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 3  ##   Integer: 0  ##   Binary: 0  ## Model sense: maximize  ## Constraints: 1"},{"path":"https://dirkschumacher.github.io/ompr/articles/modelling.html","id":"quantifiers","dir":"Articles","previous_headings":"","what":"Quantifiers","title":"Modelling techniques in OMPR","text":"add_variable, add_constraint, set_bounds, sum_over support common quantifier interface also supports filter expression. complex example show means.","code":"MIPModel() %>%    # Create x_{i, j} variables for all combinations of i and j where   # i = 1:10 and j = 1:10.   add_variable(x[i, j], type = \"binary\", i = 1:10, j = 1:10) %>%       # add a y_i variable for all i between 1 and 10 with i mod 2 = 0   add_variable(y[i], type = \"binary\", i = 1:10, i %% 2 == 0) %>%       # we maximize all x_{i,j} where i = j + 1   set_objective(sum_over(x[i, j], i = 1:10, j = 1:10, i == j + 1)) %>%       # for each i between 1 and 10 with i mod 2 = 0   # we add a constraint \\sum_j x_{i,j}   add_constraint(sum_over(x[i, j], j = 1:10) <= 1, i = 1:10, i %% 2 == 0) %>%       # of course you can leave out filters or add more than 1   add_constraint(sum_over(x[i, j], j = 1:10) <= 2, i = 1:10) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 0  ##   Integer: 0  ##   Binary: 105  ## Model sense: maximize  ## Constraints: 15"},{"path":"https://dirkschumacher.github.io/ompr/articles/modelling.html","id":"special-bounds-on-a-subset-of-variables","dir":"Articles","previous_headings":"","what":"Special bounds on a subset of variables","title":"Modelling techniques in OMPR","text":"Imagine want model matching problem single binary decision variable \\(x_{,j}\\) \\(1\\) iff object \\(\\) matched object \\(j\\). One constraint allow matches \\(\\neq j\\). can modeled constraint selectively changing bounds variables. latter approach can used solvers improve solution process.","code":"MIPModel() %>%    add_variable(x[i, j], i = 1:10, j = 1:10,                 type = \"integer\", lb = 0, ub = 1) %>%    set_objective(sum_over(x[i, j], i = 1:10, j = 1:10)) %>%    add_constraint(x[i, i] == 0, i = 1:10) %>%        # this sets the ub to 0 without adding new constraints   set_bounds(x[i, i] <= 0, i = 1:10) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 0  ##   Integer: 100  ##   Binary: 0  ## Model sense: maximize  ## Constraints: 10"},{"path":"https://dirkschumacher.github.io/ompr/articles/modelling.html","id":"external-model-parameters","dir":"Articles","previous_headings":"","what":"External model parameters","title":"Modelling techniques in OMPR","text":"course need external parameters models. can reuse variable defined R environment within MIP Model.","code":"n <- 5 # number of our variables costs <- rpois(n, lambda = 3) # a cost vector max_elements <- 3 MIPModel() %>%    add_variable(x[i], type = \"binary\", i = 1:n) %>%    set_objective(sum_over(costs[i] * x[i], i = 1:n)) %>%    add_constraint(sum_over(x[i], i = 1:n) <= max_elements) ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 0  ##   Integer: 0  ##   Binary: 5  ## Model sense: maximize  ## Constraints: 1"},{"path":"https://dirkschumacher.github.io/ompr/articles/modelling.html","id":"extract-model-solutions","dir":"Articles","previous_headings":"","what":"Extract model solutions","title":"Modelling techniques in OMPR","text":"model, pass solver get back solutions. main interface extract variable values solution function get_solution. returns data.frame indexed variable thus makes easy subsequently use value. use ROI GLPK solve . can also fix certain indexes.","code":"library(ROI) ## ROI: R Optimization Infrastructure ## Registered solver plugins: nlminb, glpk. ## Default solver: auto. library(ROI.plugin.glpk) library(ompr.roi) set.seed(1) n <- 5 weights <- matrix(rpois(n * n, 5), ncol = n, nrow = n) result <- MIPModel() %>%    add_variable(x[i, j], i = 1:n, j = 1:n, type = \"binary\") %>%    set_objective(sum_over(weights[i, j] * x[i, j], i = 1:n, j = 1:n)) %>%    add_constraint(sum_over(x[i, j], j = 1:n) == 1, i = 1:n) %>%    solve_model(with_ROI(\"glpk\", verbose = TRUE)) ## <SOLVER MSG>  ---- ## GLPK Simplex Optimizer, v4.65 ## 5 rows, 25 columns, 25 non-zeros ##       0: obj =  -0.000000000e+00 inf =   5.000e+00 (5) ##       5: obj =   2.400000000e+01 inf =   0.000e+00 (0) ## *    14: obj =   4.400000000e+01 inf =   0.000e+00 (0) ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.65 ## 5 rows, 25 columns, 25 non-zeros ## 25 integer variables, all of which are binary ## Integer optimization begins... ## Long-step dual simplex will be used ## +    14: mip =     not found yet <=              +inf        (1; 0) ## +    14: >>>>>   4.400000000e+01 <=   4.400000000e+01   0.0% (1; 0) ## +    14: mip =   4.400000000e+01 <=     tree is empty   0.0% (0; 1) ## INTEGER OPTIMAL SOLUTION FOUND ## <!SOLVER MSG> ---- get_solution(result, x[i, j]) %>%    dplyr::filter(value == 1) ##   variable i j value ## 1        x 4 1     1 ## 2        x 2 2     1 ## 3        x 5 3     1 ## 4        x 3 4     1 ## 5        x 1 5     1 get_solution(result, x[2, j]) ##   variable j value ## 1        x 1     0 ## 2        x 2     1 ## 3        x 3     0 ## 4        x 4     0 ## 5        x 5     0"},{"path":"https://dirkschumacher.github.io/ompr/articles/modelling.html","id":"feedback","dir":"Articles","previous_headings":"","what":"Feedback","title":"Modelling techniques in OMPR","text":"questions, ideas, comments? find mistake? Let’s discuss Github.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-course-assignment.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Assigning students to courses","text":"article look assignment problems. real world example problem like match group students set courses following constraints: course capacity Every student needs assigned exactly one course. students stated individual preferences scale 1 3, 3 favorable course.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-course-assignment.html","id":"the-data","dir":"Articles","previous_headings":"","what":"The data","title":"Assigning students to courses","text":"\\(n\\) students: \\(m\\) courses equal capacity. capacity can vary among courses though. addition, student three preferences. model function gives us three courses student. first component perference 1, second 2, third 3: last component need weight functions make model formulation easier. function gives us preference weighting course student pair. examples: Let’s take look random preferences. plot number votes course grouped preference (1, 2, 3).","code":"n <- 40 m <- 4 capacity <- rep.int(11, m) # all have equal capacities set.seed(1234) preference_data <- lapply(seq_len(n), function(x) sample(seq_len(m), 3)) preferences <- function(student) preference_data[[student]] preferences(1) ## [1] 4 2 3 # the weight of a student choosing a course # if the course is not among the preferences, the weight is -100000 weight <- function(student, course) {   p <- which(as.numeric(course) == preferences(as.numeric(student)))   as.integer(if (length(p) == 0) {     -100000   } else {     p   }) } weight(1, 3) ## [1] 3 weight(1, 23) # this was not a choice by student 1, so we give it a big penalty ## [1] -100000 library(ggplot2) ## Warning in register(): Can't find generic `scale_type` in package ggplot2 to ## register S3 method. library(purrr) library(dplyr) plot_data <- expand.grid(   course = seq_len(m),   weight = 1:3 ) %>% rowwise() %>%    mutate(count = sum(map_int(seq_len(n), ~weight(.x, course) == weight))) %>%    mutate(course = factor(course), weight = factor(weight)) ggplot(plot_data, aes(x = course, y = count, fill = weight)) +    geom_bar(stat = \"identity\") +    viridis::scale_fill_viridis(discrete = TRUE) +    geom_hline(yintercept = 11)"},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-course-assignment.html","id":"the-model","dir":"Articles","previous_headings":"","what":"The model","title":"Assigning students to courses","text":"idea introduce binary variable \\(x_{, j}\\) \\(1\\) student \\(\\) matched course \\(j\\). objective try satisfy preferences according weight. assigning student course preference 3 gives 3 points forth. model assumes, total capacity courses enough students. mathematical notation: \\[ \\begin{equation*} \\begin{array}{ll@{}ll} \\text{max}  & \\displaystyle\\sum\\limits_{=1}^{n}\\sum\\limits_{j=1}^{m}weight_{,j} \\cdot x_{, j} & &\\\\ \\text{subject }& \\displaystyle\\sum\\limits_{=1}^{n}   x_{, j} \\leq capacity_j,  & j=1 ,\\ldots, m&\\\\                  & \\displaystyle\\sum\\limits_{j=1}^{m}   x_{, j} = 1,  & =1 ,\\ldots, n&\\\\                  &                                                x_{,j} \\\\{0,1\\}, &=1 ,\\ldots, n, & j=1 ,\\ldots, m \\end{array} \\end{equation*} \\] directly R:","code":"library(ompr) model <- MIPModel() %>%      # 1 iff student i is assigned to course m   add_variable(x[i, j], i = 1:n, j = 1:m, type = \"binary\") %>%      # maximize the preferences   set_objective(sum_over(weight(i, j) * x[i, j], i = 1:n, j = 1:m)) %>%      # we cannot exceed the capacity of a course   add_constraint(sum_over(x[i, j], i = 1:n) <= capacity[j], j = 1:m) %>%       # each student needs to be assigned to one course   add_constraint(sum_over(x[i, j], j = 1:m) == 1, i = 1:n) model ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 0  ##   Integer: 0  ##   Binary: 160  ## Model sense: maximize  ## Constraints: 44"},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-course-assignment.html","id":"solve-the-model","dir":"Articles","previous_headings":"","what":"Solve the model","title":"Assigning students to courses","text":"use glpk solve model. solved problem objective value 118. 38 students got top preference. 2 students assigned second choice 0 students got least preferable course. course assignment now looks like :","code":"library(ompr.roi) library(ROI.plugin.glpk) result <- solve_model(model, with_ROI(solver = \"glpk\", verbose = TRUE)) ## <SOLVER MSG>  ---- ## GLPK Simplex Optimizer, v4.65 ## 44 rows, 160 columns, 320 non-zeros ##       0: obj =  -0.000000000e+00 inf =   4.000e+01 (40) ##      43: obj =  -8.999410000e+05 inf =   0.000e+00 (0) ## *   140: obj =   1.180000000e+02 inf =   0.000e+00 (0) ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.65 ## 44 rows, 160 columns, 320 non-zeros ## 160 integer variables, all of which are binary ## Integer optimization begins... ## Long-step dual simplex will be used ## +   140: mip =     not found yet <=              +inf        (1; 0) ## +   140: >>>>>   1.180000000e+02 <=   1.180000000e+02   0.0% (1; 0) ## +   140: mip =   1.180000000e+02 <=     tree is empty   0.0% (0; 1) ## INTEGER OPTIMAL SOLUTION FOUND ## <!SOLVER MSG> ---- matching <- result %>%    get_solution(x[i,j]) %>%   filter(value > .9) %>%     select(i, j) %>%    rowwise() %>%    mutate(weight = weight(as.numeric(i), as.numeric(j)),           preferences = paste0(preferences(as.numeric(i)), collapse = \",\")) %>% ungroup head(matching) ## # A tibble: 6 × 4 ##       i     j weight preferences ##   <int> <int>  <int> <chr>       ## 1     4     1      3 4,2,1       ## 2    10     1      3 3,4,1       ## 3    13     1      3 3,4,1       ## 4    15     1      3 4,2,1       ## 5    23     1      3 3,2,1       ## 6    30     1      2 3,1,2 matching %>%    group_by(weight) %>%    summarise(count = n()) ## # A tibble: 2 × 2 ##   weight count ##    <int> <int> ## 1      2     2 ## 2      3    38 plot_data <- matching %>%    mutate(course = factor(j), weight = factor(weight, levels = c(1, 2, 3))) %>%    group_by(course, weight) %>%    summarise(count = n()) %>%    tidyr::complete(weight, fill = list(count = 0)) ## `summarise()` has grouped output by 'course'. You can override using the ## `.groups` argument. ggplot(plot_data, aes(x = course, y = count, fill = weight)) +    geom_bar(stat = \"identity\") +    viridis::scale_fill_viridis(discrete = TRUE) +    geom_hline(yintercept = 11)"},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-course-assignment.html","id":"feedback","dir":"Articles","previous_headings":"","what":"Feedback","title":"Assigning students to courses","text":"questions, ideas, comments? find mistake? Let’s discuss Github.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-mtsp.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The Multiple Traveling Salesmen Problem","text":"vignette decribes solve mTSP using ompr. problem similiar standard TSP now one Salesman. Please refer vignette standard TSP background information. salesmen start end trips single location (depot). addition, salesmen need visit least one client.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-mtsp.html","id":"setting","dir":"Articles","previous_headings":"","what":"Setting","title":"The Multiple Traveling Salesmen Problem","text":"First let us import librarys number cities: number salesmen: Boundary Euclidean space: random cities depot middle:  Now distance matrix","code":"library(knitr) library(dplyr) library(ggplot2) n <- 7 m <- 2 # from 0 to ... max_x <- 500 max_y <- 500 set.seed(1) cities <- data.frame(id = 1:n, x = c(max_x / 2, runif(n - 1, max = max_x)),                                       y = c(max_y / 2, runif(n - 1, max = max_y))) %>%    mutate(is_depot = ifelse(id == 1, TRUE, FALSE)) ggplot(cities, aes(x, y)) +    geom_point(aes(size = is_depot)) +    scale_y_continuous(limits = c(0, max_y)) +    scale_x_continuous(limits = c(0, max_x)) distance <- as.matrix(dist(select(cities, x, y), diag = TRUE, upper = TRUE))"},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-mtsp.html","id":"model-formulation","dir":"Articles","previous_headings":"","what":"Model formulation","title":"The Multiple Traveling Salesmen Problem","text":"TSP example use MTZ formulation solve fairly small mTSP. basic idea extend two index formulation three indexes \\(x_{,j,k}\\) 1 iff salesman \\(k\\) travels \\(\\) \\(j\\). Import ompr. Formulate model. convention node index \\(1\\) depot.","code":"library(ompr) # the depot is always idx 1 model <- MIPModel() %>%      # we create a variable that is 1 iff we travel from city i to j by Salesman k   add_variable(x[i, j, k], i = 1:n, j = 1:n, k = 1:m, type = \"binary\") %>%      # helper variable for the MTZ sub-tour constraints   add_variable(u[i, k], i = 1:n, k = 1:m, lb = 1, ub = n) %>%      # minimize travel distance and latest arrival   set_objective(sum_over(distance[i, j] * x[i, j, k], i = 1:n, j = 1:n, k = 1:m), \"min\") %>%      # you cannot go to the same city   add_constraint(x[i, i, k] == 0, i = 1:n, k = 1:m) %>%      # each salesman needs to leave the depot   add_constraint(sum_over(x[1, j, k], j = 2:n) == 1, k = 1:m) %>%      # each salesman needs to come back to the depot   add_constraint(sum_over(x[i, 1, k], i = 2:n) == 1, k = 1:m) %>%      # if a salesman comes to a city he has to leave it as well   add_constraint(sum_over(x[j, i, k], j = 1:n) == sum_over(x[i, j, k], j = 1:n), i = 2:n, k = 1:m) %>%         # leave each city with only one salesman   add_constraint(sum_over(x[i, j, k], j = 1:n, k = 1:m) == 1, i = 2:n) %>%      # arrive at each city with only one salesman   add_constraint(sum_over(x[i, j, k], i = 1:n, k = 1:m) == 1, j = 2:n) %>%      # ensure no subtours (arc constraints)   add_constraint(u[i, k] >= 2, i = 2:n, k = 1:m) %>%   add_constraint(u[i, k] - u[j, k] + 1 <= (n - 1) * (1 - x[i, j, k]), i = 2:n, j = 2:n, k = 1:m) model ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 14  ##   Integer: 0  ##   Binary: 98  ## Model sense: minimize  ## Constraints: 126"},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-mtsp.html","id":"results","dir":"Articles","previous_headings":"","what":"Results","title":"The Multiple Traveling Salesmen Problem","text":"model can now solved one many solver libraries. use GLPK. extract solution can use get_solution method return data.frame can used tidyverse packages. Now need link back indexes model actual cities. plot :","code":"library(ompr.roi) library(ROI.plugin.glpk) result <- solve_model(model, with_ROI(solver = \"glpk\")) solution <- get_solution(result, x[i, j, k]) %>%   filter(value > 0) kable(head(solution, 3)) paths <- select(solution, i, j, k) %>%   rename(from = i, to = j, salesman = k) %>%   mutate(trip_id = row_number()) %>%   tidyr::gather(property, idx_val, from:to) %>%   mutate(idx_val = as.integer(idx_val)) %>%   inner_join(cities, by = c(\"idx_val\" = \"id\")) kable(head(arrange(paths, trip_id), 4)) ggplot(cities, aes(x, y)) +    geom_point(aes(size = is_depot)) +    geom_line(data = paths, aes(group = trip_id, color = factor(salesman))) +    ggtitle(paste0(\"Optimal route with cost: \", round(objective_value(result), 2))) +   scale_y_continuous(limits = c(0, max_y)) +    scale_x_continuous(limits = c(0, max_x))"},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-mtsp.html","id":"feedback","dir":"Articles","previous_headings":"","what":"Feedback","title":"The Multiple Traveling Salesmen Problem","text":"questions, ideas, comments? find mistake? Let’s discuss Github.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-sudoku.html","id":"solve-sudokus-using-milp","dir":"Articles","previous_headings":"","what":"Solve Sudokus using MILP","title":"Solve Sudokus","text":"vignettes solve Sudoku puzzles using MILP. Sudoku popular form constraint satisfaction problem setting objective function \\(0\\) transform optimization problem pure constraint satistication problem. document consider Sudokus 9x9 grid 3x3 sub-matrices. course can formulate objective function well directs solver towards solutions maximizing certain linear function.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-sudoku.html","id":"the-model","dir":"Articles","previous_headings":"","what":"The model","title":"Solve Sudokus","text":"idea introduce binary variable \\(x\\) three indexes \\(, j, k\\) \\(1\\) number \\(k\\) cell \\(, j\\).","code":"library(ompr) library(dplyr) n <- 9 model <- MIPModel() %>%      # The number k stored in position i,j   add_variable(x[i, j, k], i = 1:n, j = 1:n, k = 1:9, type = \"binary\") %>%      # no objective   set_objective(0) %>%      # only one number can be assigned per cell   add_constraint(sum_over(x[i, j, k], k = 1:9) == 1, i = 1:n, j = 1:n) %>%      # each number is exactly once in a row   add_constraint(sum_over(x[i, j, k], j = 1:n) == 1, i = 1:n, k = 1:9) %>%      # each number is exactly once in a column   add_constraint(sum_over(x[i, j, k], i = 1:n) == 1, j = 1:n, k = 1:9) %>%       # each 3x3 square must have all numbers   add_constraint(sum_over(x[i, j, k], i = 1:3 + sx, j = 1:3 + sy) == 1,                   sx = seq(0, n - 3, 3), sy = seq(0, n - 3, 3), k = 1:9) model ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 0  ##   Integer: 0  ##   Binary: 729  ## Model sense: maximize  ## Constraints: 324"},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-sudoku.html","id":"solve-the-model","dir":"Articles","previous_headings":"","what":"Solve the model","title":"Solve Sudokus","text":"use glpk solve model. Note haven’t fixed numbers specific values. means solver find valid sudoku without prior hints. want solve concrete sudoku can fix certain cells specific values. example solve sudoku sequence 1 9 first 3x3 matrix fixed.","code":"library(ompr.roi) library(ROI.plugin.glpk) result <- solve_model(model, with_ROI(solver = \"glpk\", verbose = TRUE)) ## <SOLVER MSG>  ---- ## GLPK Simplex Optimizer, v4.65 ## 324 rows, 729 columns, 2916 non-zeros ##       0: obj =  -0.000000000e+00 inf =   3.240e+02 (324) ##     319: obj =  -0.000000000e+00 inf =   2.141e-14 (0) 1 ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.65 ## 324 rows, 729 columns, 2916 non-zeros ## 729 integer variables, all of which are binary ## Integer optimization begins... ## Long-step dual simplex will be used ## +   319: mip =     not found yet <=              +inf        (1; 0) ## +  1102: >>>>>   0.000000000e+00 <=   0.000000000e+00   0.0% (46; 0) ## +  1102: mip =   0.000000000e+00 <=     tree is empty   0.0% (0; 91) ## INTEGER OPTIMAL SOLUTION FOUND ## <!SOLVER MSG> ---- # the following dplyr statement plots a 9x9 matrix result %>%    get_solution(x[i,j,k]) %>%   filter(value > 0) %>%     select(i, j, k) %>%    tidyr::spread(j, k) %>%    select(-i) ##   1 2 3 4 5 6 7 8 9 ## 1 6 8 1 5 9 7 4 3 2 ## 2 4 3 2 8 1 6 7 5 9 ## 3 5 7 9 3 4 2 8 1 6 ## 4 7 6 4 2 5 1 3 9 8 ## 5 1 2 8 9 7 3 6 4 5 ## 6 3 9 5 4 6 8 1 2 7 ## 7 2 1 6 7 3 5 9 8 4 ## 8 8 4 7 1 2 9 5 6 3 ## 9 9 5 3 6 8 4 2 7 1 model_fixed <- model %>%    add_constraint(x[1, 1, 1] == 1) %>%    add_constraint(x[1, 2, 2] == 1) %>%    add_constraint(x[1, 3, 3] == 1) %>%    add_constraint(x[2, 1, 4] == 1) %>%    add_constraint(x[2, 2, 5] == 1) %>%    add_constraint(x[2, 3, 6] == 1) %>%    add_constraint(x[3, 1, 7] == 1) %>%    add_constraint(x[3, 2, 8] == 1) %>%    add_constraint(x[3, 3, 9] == 1) result <- solve_model(model_fixed, with_ROI(solver = \"glpk\", verbose = TRUE)) ## <SOLVER MSG>  ---- ## GLPK Simplex Optimizer, v4.65 ## 333 rows, 729 columns, 2925 non-zeros ##       0: obj =  -0.000000000e+00 inf =   3.330e+02 (333) ##     360: obj =  -0.000000000e+00 inf =   2.197e-13 (0) 1 ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.65 ## 333 rows, 729 columns, 2925 non-zeros ## 729 integer variables, all of which are binary ## Integer optimization begins... ## Long-step dual simplex will be used ## +   360: mip =     not found yet <=              +inf        (1; 0) ## +   861: >>>>>   0.000000000e+00 <=   0.000000000e+00   0.0% (30; 0) ## +   861: mip =   0.000000000e+00 <=     tree is empty   0.0% (0; 59) ## INTEGER OPTIMAL SOLUTION FOUND ## <!SOLVER MSG> ---- result %>%    get_solution(x[i,j,k]) %>%   filter(value > 0) %>%     select(i, j, k) %>%    tidyr::spread(j, k) %>%    select(-i) ##   1 2 3 4 5 6 7 8 9 ## 1 1 2 3 4 8 9 5 7 6 ## 2 4 5 6 2 1 7 9 3 8 ## 3 7 8 9 5 6 3 1 2 4 ## 4 3 1 4 6 7 5 8 9 2 ## 5 5 6 8 3 9 2 4 1 7 ## 6 9 7 2 1 4 8 6 5 3 ## 7 6 3 7 9 5 4 2 8 1 ## 8 8 4 5 7 2 1 3 6 9 ## 9 2 9 1 8 3 6 7 4 5"},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-sudoku.html","id":"feedback","dir":"Articles","previous_headings":"","what":"Feedback","title":"Solve Sudokus","text":"questions, ideas, comments? find mistake? Let’s discuss Github.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-tsp.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The Traveling Salesman Problem","text":"vignette decribes solve TSP using ompr. Wikipedia gives following definition: travelling salesman problem (TSP) asks following question: Given list cities distances pair cities, shortest possible route visits city exactly returns origin city? Also Wikipedia article good starting point want know topic. basic definition set verticies (cities) set edges (connection cities). edge associated distance \\(d > 0\\). distance travel time, distance km monetary cost associated traveling one city another. Restrictions distances lead special cases problem. example metric-TSP requires triangle inequality holds triples edges. vignette construct TSP random points within Euclidean space.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-tsp.html","id":"setting","dir":"Articles","previous_headings":"","what":"Setting","title":"The Traveling Salesman Problem","text":"First let us import librarys number cities: Boundary Euclidean space: random cities:  Now distance matrix","code":"library(knitr) library(dplyr) library(ggplot2) n <- 10 # from 0 to ... max_x <- 500 max_y <- 500 set.seed(123456) cities <- data.frame(id = 1:n, x = runif(n, max = max_x), y = runif(n, max = max_y)) ggplot(cities, aes(x, y)) +    geom_point() distance <- as.matrix(dist(select(cities, x, y), diag = TRUE, upper = TRUE))"},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-tsp.html","id":"model-formulation","dir":"Articles","previous_headings":"","what":"Model formulation","title":"The Traveling Salesman Problem","text":"essential two prominent ways model TSP MILP. One formulate full model using Miller–Tucker–Zemlin (MTZ) formulation option use -called sub-tour elimination constraints .1 first formulation fairly compact (quadratic many constraints variables) suitable anymore n gets larger. second formulation exponential many constraints , can solve larger TSPs due better LP relaxation. idea latter approach add constraints model solution process soon solution found contains sub-tour. solution strategies like solvers usually offer callbacks let’s modify model branch--cut process - however currently supported ompr. Therefor use MTZ formulation solve fairly small TSP. Import ompr.","code":"library(ompr) model <- MIPModel() %>%      # we create a variable that is 1 iff we travel from city i to j   add_variable(x[i, j], i = 1:n, j = 1:n,                 type = \"integer\", lb = 0, ub = 1) %>%      # a helper variable for the MTZ formulation of the tsp   add_variable(u[i], i = 1:n, lb = 1, ub = n) %>%       # minimize travel distance   set_objective(sum_expr(distance[i, j] * x[i, j], i = 1:n, j = 1:n), \"min\") %>%      # you cannot go to the same city   set_bounds(x[i, i], ub = 0, i = 1:n) %>%      # leave each city   add_constraint(sum_expr(x[i, j], j = 1:n) == 1, i = 1:n) %>%      # visit each city   add_constraint(sum_expr(x[i, j], i = 1:n) == 1, j = 1:n) %>%      # ensure no subtours (arc constraints)   add_constraint(u[i] >= 2, i = 2:n) %>%    add_constraint(u[i] - u[j] + 1 <= (n - 1) * (1 - x[i, j]), i = 2:n, j = 2:n) model ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 10  ##   Integer: 100  ##   Binary: 0  ## Model sense: minimize  ## Constraints: 110"},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-tsp.html","id":"results","dir":"Articles","previous_headings":"","what":"Results","title":"The Traveling Salesman Problem","text":"model can now solved one many solver libraries. use GLPK. extract solution can use get_solution method return data.frame can used tidyverse packages. Now need link back indexes model actual cities. plot :","code":"library(ompr.roi) library(ROI.plugin.glpk) result <- solve_model(model, with_ROI(solver = \"glpk\", verbose = TRUE)) ## <SOLVER MSG>  ---- ## GLPK Simplex Optimizer, v4.65 ## 110 rows, 110 columns, 434 non-zeros ##       0: obj =   0.000000000e+00 inf =   2.900e+01 (29) ##      31: obj =   2.101879949e+03 inf =   1.110e-16 (0) ## *    60: obj =   1.450925576e+03 inf =   1.332e-15 (0) ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.65 ## 110 rows, 110 columns, 434 non-zeros ## 100 integer variables, 90 of which are binary ## Integer optimization begins... ## Long-step dual simplex will be used ## +    60: mip =     not found yet >=              -inf        (1; 0) ## +    76: >>>>>   1.469860058e+03 >=   1.450925576e+03   1.3% (3; 0) ## +    88: mip =   1.469860058e+03 >=     tree is empty   0.0% (0; 5) ## INTEGER OPTIMAL SOLUTION FOUND ## <!SOLVER MSG> ---- solution <- get_solution(result, x[i, j]) %>%    filter(value > 0)  kable(head(solution, 3)) paths <- select(solution, i, j) %>%   rename(from = i, to = j) %>%   mutate(trip_id = row_number()) %>%   tidyr::gather(property, idx_val, from:to) %>%   mutate(idx_val = as.integer(idx_val)) %>%   inner_join(cities, by = c(\"idx_val\" = \"id\")) kable(head(arrange(paths, trip_id), 4)) ggplot(cities, aes(x, y)) +    geom_point() +    geom_line(data = paths, aes(group = trip_id)) +    ggtitle(paste0(\"Optimal route with cost: \", round(objective_value(result), 2)))"},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-tsp.html","id":"feedback","dir":"Articles","previous_headings":"","what":"Feedback","title":"The Traveling Salesman Problem","text":"questions, ideas, comments? find mistake? Let’s discuss Github.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-warehouse-location.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The Warehouse Location Problem","text":"article look Warehouse Location Problem. Given set customers set locations build warehoses task decide build warehouses warehouses goods shipped customer. Thus two decisions need made : build warehouses assignment customers warehouses. simple setting also implies least one warehouse must built warehouse big enough serve customers. practical example: run logistics NGO want regularly distribute goods people need. identified set possible locations set distribution hubs, sure build . model might help. practice however might need incorporate additional constraints model.","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-warehouse-location.html","id":"the-mathematical-model","dir":"Articles","previous_headings":"","what":"The mathematical model","title":"The Warehouse Location Problem","text":"start set customers \\(C = \\{1 \\ldots n\\}\\) set possible warehouses \\(W = \\{1 \\ldots m\\}\\) built. addition cost function giving us transportation cost warehouse customer. Furthermore fixed cost associated warehouse built. basic version warehouse location problem adapted German Wikipedia page problem. \\[ \\begin{equation*} \\begin{array}{ll@{}ll} \\text{min}  & \\displaystyle\\sum\\limits_{=1}^{n}\\sum\\limits_{j=1}^{m}\\operatorname{transportcost}_{,j} \\cdot x_{, j} +  \\sum\\limits_{j=1}^{m}\\operatorname{fixedcost}_{j} \\cdot y_{j}& &\\\\ \\text{subject } & \\displaystyle\\sum\\limits_{j=1}^{m}   x_{, j} = 1  & =1 ,\\ldots, n&\\\\                   & \\displaystyle x_{, j} \\leq y_j,  & =1 ,\\ldots, n & j=1 ,\\ldots, m&\\\\                  &                                                x_{,j} \\\\{0,1\\} &=1 ,\\ldots, n, & j=1 ,\\ldots, m \\\\                  &                                                y_{j} \\\\{0,1\\} &j=1 ,\\ldots, m& \\end{array} \\end{equation*} \\]","code":""},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-warehouse-location.html","id":"the-model-in-r","dir":"Articles","previous_headings":"","what":"The model in R","title":"The Warehouse Location Problem","text":"first thing need data. article simply generate artificial data. assume customers located grid euclidian distances: warehouses also randomly placed grid. fixed cost warehouses randomly generated well mean cost 10,000. fixed costs set warehouse following: Next step build functions takes customer warehouse returns transport cost. Now let’s plot everything. Black dots customers red dots possible warehouse locations.  model ompr looks like :","code":"set.seed(1234) grid_size <- 1000 n <- 100 customer_locations <- data.frame(   id = 1:n,   x = round(runif(n) * grid_size),   y = round(runif(n) * grid_size) ) m <- 20 warehouse_locations <- data.frame(   id = 1:m,   x = round(runif(m) * grid_size),   y = round(runif(m) * grid_size) ) fixedcost <- round(rnorm(m, mean = grid_size * 10, sd = grid_size * 5)) fixedcost ##  [1]  9043  6090 20291 13753 19121 10400  6843  2434  6820 11132 15068 11264 ## [13]  4140 13344  1749  8171  8419   259 14600  6886 transportcost <- function(i, j) {   customer <- customer_locations[i, ]   warehouse <- warehouse_locations[j, ]   round(sqrt((customer$x - warehouse$x)^2 + (customer$y - warehouse$y)^2)) } transportcost(1, 3) ## [1] 302 library(ggplot2) ## Warning in register(): Can't find generic `scale_type` in package ggplot2 to ## register S3 method. p <- ggplot(customer_locations, aes(x, y)) +    geom_point() +    geom_point(data = warehouse_locations, color = \"red\", alpha = 0.5, shape = 17) +   scale_x_continuous(limits = c(0, grid_size)) +   scale_y_continuous(limits = c(0, grid_size)) +   theme(axis.title = element_blank(),          axis.ticks = element_blank(),          axis.text = element_blank(), panel.grid = element_blank()) p + ggtitle(\"Warehouse location problem\",            \"Black dots are customers. Light red triangles show potential warehouse locations.\") library(ompr) library(magrittr) model <- MIPModel() %>%   # 1 iff i gets assigned to warehouse j   add_variable(x[i, j], i = 1:n, j = 1:m, type = \"binary\") %>%      # 1 iff warehouse j is built   add_variable(y[j], j = 1:m, type = \"binary\") %>%      # maximize the preferences   set_objective(sum_over(transportcost(i, j) * x[i, j], i = 1:n, j = 1:m) +                    sum_over(fixedcost[j] * y[j], j = 1:m), \"min\") %>%      # every customer needs to be assigned to a warehouse   add_constraint(sum_over(x[i, j], j = 1:m) == 1, i = 1:n) %>%       # if a customer is assigned to a warehouse, then this warehouse must be built   add_constraint(x[i,j] <= y[j], i = 1:n, j = 1:m) model ## Mixed integer linear optimization problem ## Variables: ##   Continuous: 0  ##   Integer: 0  ##   Binary: 2020  ## Model sense: minimize  ## Constraints: 2100"},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-warehouse-location.html","id":"solve-the-model","dir":"Articles","previous_headings":"","what":"Solve the model","title":"The Warehouse Location Problem","text":"use glpk solve model. solved problem objective value 33222. last step add assignments previous plot generated.  fixed costs setting 4 warehouses :","code":"library(ompr.roi) library(ROI.plugin.glpk) result <- solve_model(model, with_ROI(solver = \"glpk\", verbose = TRUE)) ## <SOLVER MSG>  ---- ## GLPK Simplex Optimizer, v4.65 ## 2100 rows, 2020 columns, 6000 non-zeros ##       0: obj =   0.000000000e+00 inf =   1.000e+02 (100) ##     120: obj =   5.223300000e+04 inf =   0.000e+00 (0) ## Perturbing LP to avoid stalling [322]... ## Removing LP perturbation [1058]... ## *  1058: obj =   3.322200000e+04 inf =   0.000e+00 (0) 2 ## OPTIMAL LP SOLUTION FOUND ## GLPK Integer Optimizer, v4.65 ## 2100 rows, 2020 columns, 6000 non-zeros ## 2020 integer variables, all of which are binary ## Integer optimization begins... ## Long-step dual simplex will be used ## +  1058: mip =     not found yet >=              -inf        (1; 0) ## +  1058: >>>>>   3.322200000e+04 >=   3.322200000e+04   0.0% (1; 0) ## +  1058: mip =   3.322200000e+04 >=     tree is empty   0.0% (0; 1) ## INTEGER OPTIMAL SOLUTION FOUND ## <!SOLVER MSG> ---- suppressPackageStartupMessages(library(dplyr)) matching <- result %>%    get_solution(x[i,j]) %>%   filter(value > .9) %>%     select(i, j) plot_assignment <- matching %>%    inner_join(customer_locations, by = c(\"i\" = \"id\")) %>%    inner_join(warehouse_locations, by = c(\"j\" = \"id\")) customer_count <- matching %>% group_by(j) %>% summarise(n = n()) %>% rename(id = j) plot_warehouses <- warehouse_locations %>%    mutate(costs = fixedcost) %>%    inner_join(customer_count, by = \"id\") %>%    filter(id %in% unique(matching$j)) p +    geom_segment(data = plot_assignment, aes(x = x.y, y = y.y, xend = x.x, yend = y.x)) +    geom_point(data  = plot_warehouses, color = \"red\", size = 3, shape = 17) +   ggrepel::geom_label_repel(data  = plot_warehouses,                              aes(label = paste0(\"fixed costs:\", costs, \"; customers: \", n)),                              size = 2, nudge_y = 20) +    ggtitle(paste0(\"Cost optimal warehouse locations and customer assignment\"),           \"Big red triangles show warehouses that will be built, light red are unused warehouse locations.  Dots represent customers served by the respective warehouses.\") sum(fixedcost[unique(matching$j)]) ## [1] 11285"},{"path":"https://dirkschumacher.github.io/ompr/articles/problem-warehouse-location.html","id":"feedback","dir":"Articles","previous_headings":"","what":"Feedback","title":"The Warehouse Location Problem","text":"questions, ideas, comments? find mistake? Let’s discuss Github.","code":""},{"path":"https://dirkschumacher.github.io/ompr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dirk Schumacher. Author, maintainer.","code":""},{"path":"https://dirkschumacher.github.io/ompr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Schumacher D (2022). ompr: Model Solve Mixed Integer Linear Programs. R package version 1.0.1, https://github.com/dirkschumacher/ompr.","code":"@Manual{,   title = {ompr: Model and Solve Mixed Integer Linear Programs},   author = {Dirk Schumacher},   year = {2022},   note = {R package version 1.0.1},   url = {https://github.com/dirkschumacher/ompr}, }"},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"mixed-integer-linear-programming-in-r","dir":"","previous_headings":"","what":"Model and Solve Mixed Integer Linear Programs","title":"Model and Solve Mixed Integer Linear Programs","text":"OMPR (Optimization Modeling Package) DSL model solve Mixed Integer Linear Programs. inspired excellent Jump project Julia. problems solve package: cost minimal way visit set clients return home afterwards? optimal conference time table subject certain constraints (e.g. availability projector)? Sudokus Wikipedia article gives good starting point like learn topic. always happy get bug reports feedback.","code":""},{"path":[]},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"cran","dir":"","previous_headings":"Install","what":"CRAN","title":"Model and Solve Mixed Integer Linear Programs","text":"","code":"install.packages(\"ompr\") install.packages(\"ompr.roi\")"},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"development-version","dir":"","previous_headings":"Install","what":"Development version","title":"Model and Solve Mixed Integer Linear Programs","text":"install current development version use devtools:","code":"remotes::install_github(\"dirkschumacher/ompr\") remotes::install_github(\"dirkschumacher/ompr.roi\")"},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"available-solver-bindings","dir":"","previous_headings":"","what":"Available solver bindings","title":"Model and Solve Mixed Integer Linear Programs","text":"ompr.roi - Bindings ROI (GLPK, Symphony, CPLEX etc.)","code":""},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"a-simple-example","dir":"","previous_headings":"","what":"A simple example:","title":"Model and Solve Mixed Integer Linear Programs","text":"","code":"suppressPackageStartupMessages(library(dplyr, quietly = TRUE))  suppressPackageStartupMessages(library(ROI)) library(ROI.plugin.glpk) library(ompr) library(ompr.roi)  result <- MIPModel() |>   add_variable(x, type = \"integer\") |>   add_variable(y, type = \"continuous\", lb = 0) |>   set_bounds(x, lb = 0) |>   set_objective(x + y, \"max\") |>   add_constraint(x + y <= 11.25) |>   solve_model(with_ROI(solver = \"glpk\")) get_solution(result, x) #>  x  #> 11 get_solution(result, y) #>    y  #> 0.25"},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"api","dir":"","previous_headings":"","what":"API","title":"Model and Solve Mixed Integer Linear Programs","text":"functions currently form public API. detailed docs can found package function docs website","code":""},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"dsl","dir":"","previous_headings":"API","what":"DSL","title":"Model and Solve Mixed Integer Linear Programs","text":"MIPModel() create empty mixed integer linear model (old way) add_variable() adds variables model set_objective() sets objective function model set_bounds() sets bounds variables add_constraint() add constraints solve_model() solves model given solver get_solution() returns column solution (primal dual) solved model given variable group variables get_row_duals() returns row duals solution (LP) get_column_duals() returns column duals solution (LP)","code":""},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"backends","dir":"","previous_headings":"API","what":"Backends","title":"Model and Solve Mixed Integer Linear Programs","text":"currently two backends. backend function initializes empty model. MIPModel() standard MILP Model. MILPModel() another backend specifically optimized linear models often faster MIPModel(). different semantics, vectorized. Currently experimental might deprecated future.","code":""},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"solvers","dir":"","previous_headings":"API","what":"Solvers","title":"Model and Solve Mixed Integer Linear Programs","text":"Solvers different packages. ompr.ROI uses ROI package offers support kinds solvers. with_ROI(solver = \"glpk\") solve model GLPK. Install ROI.plugin.glpk with_ROI(solver = \"symphony\") solve model Symphony. Install ROI.plugin.symphony with_ROI(solver = \"cplex\") solve model CPLEX. Install ROI.plugin.cplex … See ROI package plugins.","code":""},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"further-examples","dir":"","previous_headings":"","what":"Further Examples","title":"Model and Solve Mixed Integer Linear Programs","text":"Please take look docs bigger examples.","code":""},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"knapsack","dir":"","previous_headings":"Further Examples","what":"Knapsack","title":"Model and Solve Mixed Integer Linear Programs","text":"","code":"max_capacity <- 5 n <- 10 set.seed(1234) weights <- runif(n, max = max_capacity) MIPModel() |>   add_variable(x[i], i = 1:n, type = \"binary\") |>   set_objective(sum_over(weights[i] * x[i], i = 1:n), \"max\") |>   add_constraint(sum_over(weights[i] * x[i], i = 1:n) <= max_capacity) |>   solve_model(with_ROI(solver = \"glpk\")) |>   get_solution(x[i]) |>   filter(value > 0) #>   variable i value #> 1        x 1     1 #> 2        x 6     1 #> 3        x 7     1 #> 4        x 8     1"},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"bin-packing","dir":"","previous_headings":"Further Examples","what":"Bin Packing","title":"Model and Solve Mixed Integer Linear Programs","text":"example difficult model solved GLPK","code":"max_bins <- 10 bin_size <- 3 n <- 10 weights <- runif(n, max = bin_size) MIPModel() |>   add_variable(y[i], i = 1:max_bins, type = \"binary\") |>   add_variable(x[i, j], i = 1:max_bins, j = 1:n, type = \"binary\") |>   set_objective(sum_over(y[i], i = 1:max_bins), \"min\") |>   add_constraint(sum_over(weights[j] * x[i, j], j = 1:n) <= y[i] * bin_size, i = 1:max_bins) |>   add_constraint(sum_over(x[i, j], i = 1:max_bins) == 1, j = 1:n) |>   solve_model(with_ROI(solver = \"glpk\", verbose = TRUE)) |>   get_solution(x[i, j]) |>   filter(value > 0) |>   arrange(i) #> <SOLVER MSG>  ---- #> GLPK Simplex Optimizer, v4.65 #> 20 rows, 110 columns, 210 non-zeros #>       0: obj =   0.000000000e+00 inf =   1.000e+01 (10) #>      29: obj =   4.546337429e+00 inf =   0.000e+00 (0) #> *    34: obj =   4.546337429e+00 inf =   0.000e+00 (0) #> OPTIMAL LP SOLUTION FOUND #> GLPK Integer Optimizer, v4.65 #> 20 rows, 110 columns, 210 non-zeros #> 110 integer variables, all of which are binary #> Integer optimization begins... #> Long-step dual simplex will be used #> +    34: mip =     not found yet >=              -inf        (1; 0) #> +    62: >>>>>   5.000000000e+00 >=   5.000000000e+00   0.0% (13; 0) #> +    62: mip =   5.000000000e+00 >=     tree is empty   0.0% (0; 25) #> INTEGER OPTIMAL SOLUTION FOUND #> <!SOLVER MSG> ---- #>    variable  i  j value #> 1         x  1  2     1 #> 2         x  1  9     1 #> 3         x  1 10     1 #> 4         x  2  5     1 #> 5         x  2  7     1 #> 6         x  2  8     1 #> 7         x  3  6     1 #> 8         x  4  4     1 #> 9         x 10  1     1 #> 10        x 10  3     1"},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Model and Solve Mixed Integer Linear Programs","text":"MIT","code":""},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Model and Solve Mixed Integer Linear Programs","text":"Please post issue first sending PR. Please note project released Contributor Code Conduct. participating project agree abide terms.","code":""},{"path":"https://dirkschumacher.github.io/ompr/index.html","id":"related-projects","dir":"","previous_headings":"","what":"Related Projects","title":"Model and Solve Mixed Integer Linear Programs","text":"CVXR - excellent package “object-oriented modeling language convex optimization”. LP/MIP special case. ROML follows similar approach, seems package still initial development.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/MILPModel.html","id":null,"dir":"Reference","previous_headings":"","what":"Experimental: Create a new MILP Model — MILPModel","title":"Experimental: Create a new MILP Model — MILPModel","text":"Create empty mixed-integer linear programming model 1000 times faster `MIPModel`.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/MILPModel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Experimental: Create a new MILP Model — MILPModel","text":"","code":"MILPModel()"},{"path":"https://dirkschumacher.github.io/ompr/reference/MILPModel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Experimental: Create a new MILP Model — MILPModel","text":"Please use can deal potential API changes future. use `MILPModel` make sure always model problem `MIPModel` well, just make sure get results. also always good idea test model small input sizes examine coefficients rows constraint matrix.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/MIPModel.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new MIP Model — MIPModel","title":"Create a new MIP Model — MIPModel","text":"Create new MIP Model","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/MIPModel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new MIP Model — MIPModel","text":"","code":"MIPModel()"},{"path":"https://dirkschumacher.github.io/ompr/reference/add_constraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a constraint — add_constraint","title":"Add a constraint — add_constraint","text":"Add one constraints model using quantifiers.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/add_constraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a constraint — add_constraint","text":"","code":"add_constraint(.model, .constraint_expr, ..., .show_progress_bar = TRUE)  add_constraint_(   .model,   .constraint_expr,   ...,   .dots,   .show_progress_bar = TRUE )"},{"path":"https://dirkschumacher.github.io/ompr/reference/add_constraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a constraint — add_constraint","text":".model model .constraint_expr constraint. Must linear ()equality operator \"<=\", \"==\" \">=\". ... quantifiers indexed variables. combinations bound variables new constraint created. addition can add filter expressions .show_progress_bar displays progressbar adding multiple constraints .dots Used work around non-standard evaluation.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/add_constraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a constraint — add_constraint","text":"Model new constraints added","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/add_constraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a constraint — add_constraint","text":"","code":"library(magrittr) MIPModel() %>%   add_variable(x[i], i = 1:5) %>%   # creates 5 constraints   add_constraint(x[i] >= 1, i = 1:5) %>%   # you can also use filter expressions   add_constraint(x[i] >= 1, i = 1:5, i %% 2 == 0) %>%   # and depent on other indexes   add_constraint(x[j] >= 1, i = 1:10, j = 1:i, j <= 5) #> Mixed integer linear optimization problem #> Variables: #>   Continuous: 5  #>   Integer: 0  #>   Binary: 0  #> No objective function.  #> Constraints: 47"},{"path":"https://dirkschumacher.github.io/ompr/reference/add_variable.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a variable to the model — add_variable","title":"Add a variable to the model — add_variable","text":"variable can either name indexed name. See examples.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/add_variable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a variable to the model — add_variable","text":"","code":"add_variable(.model, .variable, ..., type = \"continuous\", lb = -Inf, ub = Inf)  add_variable_(   .model,   .variable,   ...,   type = \"continuous\",   lb = -Inf,   ub = Inf,   .dots )"},{"path":"https://dirkschumacher.github.io/ompr/reference/add_variable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a variable to the model — add_variable","text":".model model .variable variable name/definition ... quantifiers indexed variable. Including filters type must either continuous, integer binary lb lower bound variable ub upper bound variable .dots Used work around non-standard evaluation.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/add_variable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add a variable to the model — add_variable","text":"","code":"library(magrittr) MIPModel() %>%   add_variable(x) %>% # creates 1 variable named x   add_variable(y[i],     i = 1:10, i %% 2 == 0,     type = \"binary\"   ) # creates 4 variables #> Mixed integer linear optimization problem #> Variables: #>   Continuous: 1  #>   Integer: 0  #>   Binary: 5  #> No objective function.  #> Constraints: 0"},{"path":"https://dirkschumacher.github.io/ompr/reference/additional_solver_output.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve additional solver specific output — additional_solver_output","title":"Retrieve additional solver specific output — additional_solver_output","text":"Retrieve additional solver specific output","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/additional_solver_output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve additional solver specific output — additional_solver_output","text":"","code":"additional_solver_output(solution)"},{"path":"https://dirkschumacher.github.io/ompr/reference/additional_solver_output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve additional solver specific output — additional_solver_output","text":"solution solution object","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/additional_solver_output.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve additional solver specific output — additional_solver_output","text":"list named entries. list determined solver function. ompr.roi usually solver specific message status information.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/as_colwise.html","id":null,"dir":"Reference","previous_headings":"","what":"As_colwise — as_colwise","title":"As_colwise — as_colwise","text":"Convert lists vectors colwise semantic.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/as_colwise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"As_colwise — as_colwise","text":"","code":"as_colwise(x)"},{"path":"https://dirkschumacher.github.io/ompr/reference/as_colwise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"As_colwise — as_colwise","text":"x list numeric vectors numeric vector","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/colwise.html","id":null,"dir":"Reference","previous_headings":"","what":"Format variables colwise — colwise","title":"Format variables colwise — colwise","text":"function used expand variable across columns rows. passing vector indexes MILPModel variable, creates new row vector element. colwise can create columns instead. Please see examples .","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/colwise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format variables colwise — colwise","text":"","code":"colwise(...)"},{"path":"https://dirkschumacher.github.io/ompr/reference/colwise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format variables colwise — colwise","text":"... create colwise vector","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/colwise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Format variables colwise — colwise","text":"`colwise` probably concept likely change future.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/colwise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format variables colwise — colwise","text":"","code":"if (FALSE) { # vectors create matrix rows # x[1, 1] # x[2, 1] # x[3, 1] x[1:3, 1]  # colwise() creates columns per row # 1 * x[1, 1] + 2 * x[1, 2] + 3 * x[1, 3] colwise(1, 2, 3) * x[1, colwise(1, 2, 3)]  # or you have multiple rows and columns and different coefficients # 1 * x[1, 1] + 2 * x[1, 2] + 3 * x[1, 3] # 4 * x[2, 1] + 5 * x[2, 2] + 6 * x[1, 3] colwise(1:6) * x[1:2, colwise(1:3)] # in the example above, the colwise vector multiplied with the variable # has an element per row and column # in general, it can be a multiple of number of columns  # you can also combine the two # x[1, 1] # x[2, 1] + x[2, 2] # x[3, 1] + x[3, 2] + x[3, 2] x[1:3, colwise(1, 1:2, 1:3)] }"},{"path":"https://dirkschumacher.github.io/ompr/reference/extract_bound_from_constraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a scalar bound for a variable from a constraint — extract_bound_from_constraint","title":"Extract a scalar bound for a variable from a constraint — extract_bound_from_constraint","text":"Extract scalar bound variable constraint","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/extract_bound_from_constraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a scalar bound for a variable from a constraint — extract_bound_from_constraint","text":"","code":"extract_bound_from_constraint(lhs, rhs, sense)  # S4 method for LinearFunction,numeric,LinearConstraintSense extract_bound_from_constraint(lhs, rhs, sense)  # S4 method for LinearTerm,numeric,LinearConstraintSense extract_bound_from_constraint(lhs, rhs, sense)"},{"path":"https://dirkschumacher.github.io/ompr/reference/extract_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the constraint matrix, the right hand side and the sense from a model — extract_constraints","title":"Extract the constraint matrix, the right hand side and the sense from a model — extract_constraints","text":"Extract constraint matrix, right hand side sense model","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/extract_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the constraint matrix, the right hand side and the sense from a model — extract_constraints","text":"","code":"extract_constraints(model)"},{"path":"https://dirkschumacher.github.io/ompr/reference/extract_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the constraint matrix, the right hand side and the sense from a model — extract_constraints","text":"model model","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/extract_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the constraint matrix, the right hand side and the sense from a model — extract_constraints","text":"list three named elements.         'matrix' (sparse) constraint matrix Matrix package.         'rhs' right hand side vector order matrix.         'sense' vector constraint senses","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/extract_constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the constraint matrix, the right hand side and the sense from a model — extract_constraints","text":"","code":"library(magrittr) model <- MIPModel() %>%   add_variable(x[i], i = 1:3) %>%   add_variable(y[i], i = 1:3) %>%   add_constraint(x[i] + y[i] <= 1, i = 1:3) extract_constraints(model) #> $matrix #> 3 x 6 sparse Matrix of class \"dgCMatrix\" #>                  #> [1,] 1 . . 1 . . #> [2,] . 1 . . 1 . #> [3,] . . 1 . . 1 #>  #> $sense #> [1] \"<=\" \"<=\" \"<=\" #>  #> $rhs #> [1] 1 1 1 #>"},{"path":"https://dirkschumacher.github.io/ompr/reference/get_column_duals.html","id":null,"dir":"Reference","previous_headings":"","what":"Gets the column duals of a solution — get_column_duals","title":"Gets the column duals of a solution — get_column_duals","text":"Gets column duals solution","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/get_column_duals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gets the column duals of a solution — get_column_duals","text":"","code":"get_column_duals(solution)"},{"path":"https://dirkschumacher.github.io/ompr/reference/get_column_duals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gets the column duals of a solution — get_column_duals","text":"solution solution","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/get_column_duals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gets the column duals of a solution — get_column_duals","text":"Either numeric vector one element per column `NA_real_`.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/get_column_duals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gets the column duals of a solution — get_column_duals","text":"","code":"if (FALSE) { result <- MIPModel() %>%   add_variable(x[i], i = 1:5) %>%   add_variable(y[i, j], i = 1:5, j = 1:5) %>%   add_constraint(x[i] >= 1, i = 1:5) %>%   set_bounds(x[i], lb = 3, i = 1:3) %>%   set_objective(sum_over(i * x[i], i = 1:5)) %>%   solve_model(with_ROI(\"glpk\"))  get_column_duals(result) }"},{"path":"https://dirkschumacher.github.io/ompr/reference/get_row_duals.html","id":null,"dir":"Reference","previous_headings":"","what":"Gets the row duals of a solution — get_row_duals","title":"Gets the row duals of a solution — get_row_duals","text":"Gets row duals solution","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/get_row_duals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gets the row duals of a solution — get_row_duals","text":"","code":"get_row_duals(solution)"},{"path":"https://dirkschumacher.github.io/ompr/reference/get_row_duals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gets the row duals of a solution — get_row_duals","text":"solution solution","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/get_row_duals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gets the row duals of a solution — get_row_duals","text":"Either numeric vector one element per row `NA_real_`.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/get_row_duals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gets the row duals of a solution — get_row_duals","text":"","code":"if (FALSE) { result <- MIPModel() %>%   add_variable(x[i], i = 1:5) %>%   add_variable(y[i, j], i = 1:5, j = 1:5) %>%   add_constraint(x[i] >= 1, i = 1:5) %>%   set_bounds(x[i], lb = 3, i = 1:3) %>%   set_objective(sum_expr(i * x[i], i = 1:5)) %>%   solve_model(with_ROI(\"glpk\"))  get_row_duals(result) }"},{"path":"https://dirkschumacher.github.io/ompr/reference/get_solution.html","id":null,"dir":"Reference","previous_headings":"","what":"Get variable values from a solution — get_solution","title":"Get variable values from a solution — get_solution","text":"Get variable values solution","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/get_solution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get variable values from a solution — get_solution","text":"","code":"get_solution(solution, expr, type = \"primal\")  get_solution_(solution, expr, type = \"primal\")"},{"path":"https://dirkschumacher.github.io/ompr/reference/get_solution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get variable values from a solution — get_solution","text":"solution solution object expr variable expression. can partially bind indexes. type optional, either \"primal\" \"dual\". default value \"primal\". \"primal\" returns primal solution, otherwise column duals. Especially dual values depend solver. duals calculated, function stops error message.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/get_solution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get variable values from a solution — get_solution","text":"data.frame. One row variable instance         column index.         Unless single variable, returns single number.         Please note case data.frame         guarantee ordering rows. change         future ompr versions. Please always use indexes         retrieve correct values.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/get_solution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get variable values from a solution — get_solution","text":"","code":"if (FALSE) { library(magrittr) result <- MIPModel() %>%   add_variable(x[i], i = 1:5) %>%   add_variable(y[i, j], i = 1:5, j = 1:5) %>%   add_constraint(x[i] >= 1, i = 1:5) %>%   set_bounds(x[i], lb = 3, i = 1:3) %>%   set_objective(0) %>%   solve_model(with_ROI(\"glpk\")) solution <- get_solution(result, x[i]) solution2 <- get_solution(result, y[i, 1]) solution3 <- get_solution(result, y[i, j]) duals <- get_solution(result, x[i], type = \"dual\") }"},{"path":"https://dirkschumacher.github.io/ompr/reference/linear-constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal linear constraints classes and methods — LinearConstraintSense-class","title":"Internal linear constraints classes and methods — LinearConstraintSense-class","text":"Internal linear constraints classes methods","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/linear-constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal linear constraints classes and methods — LinearConstraintSense-class","text":"","code":"flip_constaint_sense(sense)  # S4 method for LinearConstraintSenseLeq flip_constaint_sense(sense)  # S4 method for LinearConstraintSenseGeq flip_constaint_sense(sense)  new_linear_constraint(lhs, rhs, sense)  # S4 method for LinearFunction,numeric,LinearConstraintSense new_linear_constraint(lhs, rhs, sense)  # S4 method for LinearFunction,LinearTerm,LinearConstraintSense new_linear_constraint(lhs, rhs, sense)  # S4 method for LinearFunction,LinearFunction,LinearConstraintSense new_linear_constraint(lhs, rhs, sense)  # S4 method for LinearTerm,ANY,LinearConstraintSense new_linear_constraint(lhs, rhs, sense)  # S4 method for AbstractLinearFunction,ANY &lt;=(e1, e2)  # S4 method for AbstractLinearFunction,ANY ==(e1, e2)  # S4 method for AbstractLinearFunction,ANY &gt;=(e1, e2)  # S4 method for ANY,AbstractLinearFunction &lt;=(e1, e2)  # S4 method for ANY,AbstractLinearFunction ==(e1, e2)  # S4 method for ANY,AbstractLinearFunction &gt;=(e1, e2)"},{"path":"https://dirkschumacher.github.io/ompr/reference/linear-constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal linear constraints classes and methods — LinearConstraintSense-class","text":"sense constraint sense lhs linear function rhs numeric scalar e1 parameter e2 parameter","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/linear-constraints.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Internal linear constraints classes and methods — LinearConstraintSense-class","text":"sense leq, geq eq","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/linear-functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal linear function classes and methods — OmprLinearVariable-class","title":"Internal linear function classes and methods — OmprLinearVariable-class","text":"Internal linear function classes methods","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/linear-functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal linear function classes and methods — OmprLinearVariable-class","text":"","code":"# S4 method for LinearTerm,numeric *(e1, e2)  # S4 method for numeric,LinearTerm *(e1, e2)  # S4 method for LinearTerm,numeric /(e1, e2)  # S4 method for LinearTerm,numeric +(e1, e2)  # S4 method for numeric,LinearTerm +(e1, e2)  # S4 method for LinearTerm,missing +(e1, e2)  # S4 method for LinearTerm,LinearTerm +(e1, e2)  # S4 method for LinearTerm,missing -(e1, e2)  # S4 method for LinearFunction,numeric +(e1, e2)  # S4 method for numeric,LinearFunction +(e1, e2)  # S4 method for LinearFunction,LinearTerm +(e1, e2)  # S4 method for LinearTerm,LinearFunction +(e1, e2)  # S4 method for LinearFunction,LinearFunction +(e1, e2)  # S4 method for LinearFunction,numeric -(e1, e2)  # S4 method for numeric,LinearFunction -(e1, e2)  # S4 method for LinearTerm,LinearTerm -(e1, e2)  # S4 method for numeric,LinearTerm -(e1, e2)  # S4 method for LinearFunction,LinearTerm -(e1, e2)  # S4 method for LinearTerm,LinearFunction -(e1, e2)  # S4 method for LinearFunction,LinearFunction -(e1, e2)  # S4 method for LinearFunction,LinearFunction -(e1, e2)  # S4 method for LinearFunction,numeric *(e1, e2)  # S4 method for numeric,LinearFunction *(e1, e2)  # S4 method for LinearFunction,numeric /(e1, e2)  # S4 method for OmprLinearVariableCollection,ANY,ANY,missing [(x, i, j, ..., drop = TRUE)  # S4 method for OmprLinearVariableCollection length(x)  # S4 method for OmprLinearVariable length(x)"},{"path":"https://dirkschumacher.github.io/ompr/reference/linear-functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal linear function classes and methods — OmprLinearVariable-class","text":"e1 parameter e2 parameter x value index j index ... indexes drop unused","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/milp-linear-variables.html","id":null,"dir":"Reference","previous_headings":"","what":"An S4 class that represents a collection of variables — LinearVariableCollection-class","title":"An S4 class that represents a collection of variables — LinearVariableCollection-class","text":"multiply numeric vector constant variable 'LinearVariableSum' multiply numeric vector constant variable 'LinearVariableSum' Equivalent `e1 + -1 * e2` Equivalent `(-1 * e2) - (-1 * e1)` Add two object 'LinearVariableSum'. .e. variables + constants Equivalent `e1 + (-1) * e2` Adds variables rhs variables lhs returns another 'LinearVariableSum'. Equivalent `e2 + e1` Equivalent `-1 * (e2 - e1)` Equivalent `e1 + -1 * e2` Adds constant (rhs) constant slot lhs object. Equivalent `e2 + e1` Equivalent `e1 * (-1)` Equivalent `e1 * (-1)` Equivalent `e1` Equivalent `e1` Adds constant numeric vector variable. constant needs vector length 1. Equivalent `e2 + e1` Equivalent `e1 + -1 * e2` Equivalent `(-1 * e2) - (-1 * e1)` Equivalent `e1 * (1 / e2)` Equivalent `e1 * (1 / e2)` Adds two variables together. values variable, row col added. Everything else merged. Equivalent `e1 + -1 * e2` Multiplies coefficients rowwise given numeric vector. numeric vector `linear_transposed_vector`, multiply vector variable per row. Equivalent `e2 * e1` creates new variable collection subset previously defined indexed variable. variable collection essentially data frame values rows columns final model matrix.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/milp-linear-variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An S4 class that represents a collection of variables — LinearVariableCollection-class","text":"","code":"# S4 method for LinearVariableSum,numeric *(e1, e2)  # S4 method for numeric,LinearVariableSum *(e1, e2)  # S4 method for LinearVariableSum,numeric -(e1, e2)  # S4 method for numeric,LinearVariableSum -(e1, e2)  # S4 method for LinearVariableSum,LinearVariableSum +(e1, e2)  # S4 method for LinearVariableSum,LinearVariableSum -(e1, e2)  # S4 method for LinearVariableSum,LinearVariableCollection +(e1, e2)  # S4 method for LinearVariableCollection,LinearVariableSum +(e1, e2)  # S4 method for LinearVariableCollection,LinearVariableSum -(e1, e2)  # S4 method for LinearVariableSum,LinearVariableCollection -(e1, e2)  # S4 method for LinearVariableSum,numeric +(e1, e2)  # S4 method for numeric,LinearVariableSum +(e1, e2)  # S4 method for LinearVariableSum,missing -(e1, e2)  # S4 method for LinearVariableCollection,missing -(e1, e2)  # S4 method for LinearVariableSum,missing +(e1, e2)  # S4 method for LinearVariableCollection,missing +(e1, e2)  # S4 method for LinearVariableCollection,numeric +(e1, e2)  # S4 method for numeric,LinearVariableCollection +(e1, e2)  # S4 method for LinearVariableCollection,numeric -(e1, e2)  # S4 method for numeric,LinearVariableCollection -(e1, e2)  # S4 method for LinearVariableCollection,numeric /(e1, e2)  # S4 method for LinearVariableSum,numeric /(e1, e2)  # S4 method for LinearVariableCollection,LinearVariableCollection +(e1, e2)  # S4 method for LinearVariableCollection,LinearVariableCollection -(e1, e2)  # S4 method for LinearVariableCollection,numeric *(e1, e2)  # S4 method for numeric,LinearVariableCollection *(e1, e2)  # S4 method for LinearVariableCollection,ANY,ANY,missing [(x, i, j, ..., drop = TRUE)"},{"path":"https://dirkschumacher.github.io/ompr/reference/milp-linear-variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"An S4 class that represents a collection of variables — LinearVariableCollection-class","text":"e1 numeric value e2 object type 'LinearVariableCollection' x object type 'LinearVariableCollection' numeric vector colwise vector/list j numeric vector colwise vector/list ... numeric vectors colwise vector/list drop use parameter","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/milp-linear-variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"An S4 class that represents a collection of variables — LinearVariableCollection-class","text":"Returns object type 'LinearVariableSum' Returns object type 'LinearVariableSum' Returns object type 'LinearVariableSum' object type 'LinearVariableSum' new object type 'LinearVariableCollection'","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/milp-linear-variables.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"An S4 class that represents a collection of variables — LinearVariableCollection-class","text":"variables data frame hold variable coefficients. One line reach variable, row column. index_mapping function takes variable name character returns mapping table maps column ids variable indexes. variable linear variable collection just one index '1' constant numeric vector variables variable collection","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/milp-linear-variables.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"An S4 class that represents a collection of variables — LinearVariableCollection-class","text":"","code":"if (FALSE) { # vectors create matrix rows # x[1, 1] # x[2, 1] # x[3, 1] x[1:3, 1]  # colwise() creates columns per row # 1 * x[1, 1] + 2 * x[1, 2] + 3 * x[1, 3] colwise(1, 2, 3) * x[1, colwise(1, 2, 3)]  # you can also combine the two # x[1, 1] # x[2, 1] + x[2, 2] # x[3, 1] + x[3, 2] + x[3, 2] x[1:3, colwise(1, 1:2, 1:3)] }"},{"path":"https://dirkschumacher.github.io/ompr/reference/nconstraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of variables (rows) of the model — nconstraints","title":"Number of variables (rows) of the model — nconstraints","text":"Number variables (rows) model","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/nconstraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of variables (rows) of the model — nconstraints","text":"","code":"nconstraints(model)"},{"path":"https://dirkschumacher.github.io/ompr/reference/nconstraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of variables (rows) of the model — nconstraints","text":"model model","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/nconstraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of variables (rows) of the model — nconstraints","text":"integer equal number variables. variable column resulting constraint matrix.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/nconstraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of variables (rows) of the model — nconstraints","text":"","code":"library(magrittr) model <- MIPModel() %>%   add_variable(x) %>%   add_variable(y[i], i = 1:10) nconstraints(model) # 11 #> [1] 0"},{"path":"https://dirkschumacher.github.io/ompr/reference/new_solution.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new solution — new_solution","title":"Create a new solution — new_solution","text":"function/class used develop solver.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/new_solution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new solution — new_solution","text":"","code":"new_solution(   model,   objective_value,   status,   solution,   solution_column_duals = function() NA_real_,   solution_row_duals = function() NA_real_,   additional_solver_output = list() )"},{"path":"https://dirkschumacher.github.io/ompr/reference/new_solution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new solution — new_solution","text":"model optimization model solved objective_value numeric objective value status status solution solution named numeric vector containing primal solution values solution_column_duals function without arguments returns numeric vector containing column dual solution values. `NA_real_`, column duals available/defined. solution_row_duals function without arguments returns numeric vector containing column dual solution values. `NA_real_`, column duals available/defined. additional_solver_output named list additional solver information","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/nvars.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of variables of a model — nvars","title":"Number of variables of a model — nvars","text":"Number variables model","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/nvars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of variables of a model — nvars","text":"","code":"nvars(model)"},{"path":"https://dirkschumacher.github.io/ompr/reference/nvars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of variables of a model — nvars","text":"model model","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/nvars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of variables of a model — nvars","text":"list three named elements.         'binary' => number binary variables,         'integer' => number integer variables,         'continuous' => number continuous variables.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/nvars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of variables of a model — nvars","text":"","code":"library(magrittr) model <- MIPModel() %>%   add_variable(x[i], i = 1:10, type = \"binary\") %>%   add_variable(y[i], i = 1:5, type = \"continuous\") %>%   add_variable(z[i], i = 1:2, type = \"integer\") nvars(model) #> $continuous #> [1] 5 #>  #> $integer #> [1] 2 #>  #> $binary #> [1] 10 #>"},{"path":"https://dirkschumacher.github.io/ompr/reference/objective_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the objective function from a model — objective_function","title":"Extract the objective function from a model — objective_function","text":"Extract objective function model","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/objective_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the objective function from a model — objective_function","text":"","code":"objective_function(model)"},{"path":"https://dirkschumacher.github.io/ompr/reference/objective_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the objective function from a model — objective_function","text":"model model","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/objective_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the objective function from a model — objective_function","text":"list two named elements, 'solution' 'constant'. 'solution' sparse vector Matrix package. 'constant' constant needs added get final obj. value.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/objective_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the objective function from a model — objective_function","text":"","code":"library(magrittr) model <- MIPModel() %>%   add_variable(x[i], i = 1:5) %>%   set_objective(sum_over(i * x[i], i = 1:5) + 10) objective_function(model) #> $solution #> sparse vector (nnz/length = 5/5) of class \"dsparseVector\" #> [1] 1 2 3 4 5 #>  #> $constant #> [1] 10 #>"},{"path":"https://dirkschumacher.github.io/ompr/reference/objective_value.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the numerical objective value from a solution — objective_value","title":"Extract the numerical objective value from a solution — objective_value","text":"Extract numerical objective value solution","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/objective_value.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the numerical objective value from a solution — objective_value","text":"","code":"objective_value(solution)"},{"path":"https://dirkschumacher.github.io/ompr/reference/objective_value.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the numerical objective value from a solution — objective_value","text":"solution solution","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/objective_value.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the numerical objective value from a solution — objective_value","text":"numeric single item vector","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/ompr.html","id":null,"dir":"Reference","previous_headings":"","what":"A package to Model (Mixed) Integer Programs — ompr","title":"A package to Model (Mixed) Integer Programs — ompr","text":"package model (mixed) integer programs. provides algebraic way model mixed integer linear optimization problems directly R. model solver-independent thus offers possibility solve model different solvers. See ompr website <https://dirkschumacher.github.io/ompr/> information, documentation examples.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/set_bounds.html","id":null,"dir":"Reference","previous_headings":"","what":"Set the bounds of a variable — set_bounds","title":"Set the bounds of a variable — set_bounds","text":"Change lower upper bounds named variable, indexed variable group variables.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/set_bounds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set the bounds of a variable — set_bounds","text":"","code":"set_bounds(.model, .variable, ..., lb = NULL, ub = NULL)  set_bounds_(.model, .variable, ..., lb = NULL, ub = NULL, .dots)"},{"path":"https://dirkschumacher.github.io/ompr/reference/set_bounds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set the bounds of a variable — set_bounds","text":".model model .variable variable name/definition linear constraint ... quantifiers indexed variable lb lower bound variable. ub upper bound variable MIPModel can also pass ()equalities define bounds. Please look examples. .dots Used work around non-standard evaluation.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/set_bounds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set the bounds of a variable — set_bounds","text":"","code":"library(magrittr) MIPModel() %>%   add_variable(x[i], i = 1:5) %>%   add_constraint(x[i] >= 1, i = 1:5) %>% # creates 5 constraints   set_bounds(x[i], lb = 3, i = 1:3) %>%   variable_bounds() #> $lower #> [1]    3    3    3 -Inf -Inf #>  #> $upper #> [1] Inf Inf Inf Inf Inf #>   MIPModel() %>%   add_variable(x[i], i = 1:5) %>%   set_bounds(x[i] <= i, i = 1:5) %>% # upper bound   set_bounds(x[i] >= 0, i = 1:5) %>% # lower bound   set_bounds(x[5] == 45) %>%   variable_bounds() #> $lower #> [1]  0  0  0  0 45 #>  #> $upper #> [1]  1  2  3  4 45 #>"},{"path":"https://dirkschumacher.github.io/ompr/reference/set_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Set the model objective — set_objective","title":"Set the model objective — set_objective","text":"Set model objective","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/set_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set the model objective — set_objective","text":"","code":"set_objective(model, expression, sense = c(\"max\", \"min\"))  set_objective_(model, expression, sense = c(\"max\", \"min\"))"},{"path":"https://dirkschumacher.github.io/ompr/reference/set_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set the model objective — set_objective","text":"model model expression linear objective sum variables constants sense model sense. Must either \"max\" \"min\".","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/set_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set the model objective — set_objective","text":"Model new objective function definition","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/set_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set the model objective — set_objective","text":"","code":"library(magrittr) MIPModel() %>%   add_variable(x, lb = 2) %>%   add_variable(y, lb = 40) %>%   set_objective(x + y, sense = \"min\") #> Mixed integer linear optimization problem #> Variables: #>   Continuous: 2  #>   Integer: 0  #>   Binary: 0  #> Model sense: minimize  #> Constraints: 0"},{"path":"https://dirkschumacher.github.io/ompr/reference/solve_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve a model — solve_model","title":"Solve a model — solve_model","text":"Solve model","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/solve_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve a model — solve_model","text":"","code":"solve_model(model, solver)"},{"path":"https://dirkschumacher.github.io/ompr/reference/solve_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve a model — solve_model","text":"model model solver function mapping model solution","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/solve_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve a model — solve_model","text":"solver(model)","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/solver_status.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the solver status from a solution — solver_status","title":"Get the solver status from a solution — solver_status","text":"Get solver status solution","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/solver_status.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the solver status from a solution — solver_status","text":"","code":"solver_status(solution)"},{"path":"https://dirkschumacher.github.io/ompr/reference/solver_status.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the solver status from a solution — solver_status","text":"solution solution","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/solver_status.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the solver status from a solution — solver_status","text":"character vector either \"infeasible\", \"optimal\", \"unbounded\", \"userlimit\" \"error","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/sum_over.html","id":null,"dir":"Reference","previous_headings":"","what":"Sum over indexes — sum_over","title":"Sum over indexes — sum_over","text":"functions helps create summations indexes.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/sum_over.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sum over indexes — sum_over","text":"","code":"sum_over(.expr, ...)  sum_expr(.expr, ...)"},{"path":"https://dirkschumacher.github.io/ompr/reference/sum_over.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sum over indexes — sum_over","text":".expr expression can expanded sum ... bind variables expr using dots. See examples.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/sum_over.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sum over indexes — sum_over","text":"sum indexes","code":""},{"path":[]},{"path":"https://dirkschumacher.github.io/ompr/reference/sum_over.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sum over indexes — sum_over","text":"","code":"if (FALSE) {   # create a sum from x_1 to x_10   sum_over(x[i], i = 1:10)   # create a sum from x_2 to x_10 with even indexes   sum_over(x[i], i = 1:10, i %% 2 == 0)   sum_over(x[i, j], i = 1:10, j = 1:i) }"},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_bounds.html","id":null,"dir":"Reference","previous_headings":"","what":"Variable lower and upper bounds of a model — variable_bounds","title":"Variable lower and upper bounds of a model — variable_bounds","text":"Variable lower upper bounds model","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_bounds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variable lower and upper bounds of a model — variable_bounds","text":"","code":"variable_bounds(model)"},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_bounds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variable lower and upper bounds of a model — variable_bounds","text":"model model","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_bounds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variable lower and upper bounds of a model — variable_bounds","text":"list two components 'lower' 'upper' numeric vector bounds. One variable.","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_bounds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Variable lower and upper bounds of a model — variable_bounds","text":"","code":"library(magrittr) model <- MIPModel() %>%   add_variable(x, type = \"binary\") %>%   add_variable(y, type = \"continuous\", lb = 2) %>%   add_variable(z, type = \"integer\", ub = 3) variable_bounds(model) #> $lower #> [1]    0    2 -Inf #>  #> $upper #> [1]   1 Inf   3 #>"},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_keys.html","id":null,"dir":"Reference","previous_headings":"","what":"Get all unique names of the model variables — variable_keys","title":"Get all unique names of the model variables — variable_keys","text":"Get unique names model variables","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_keys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get all unique names of the model variables — variable_keys","text":"","code":"variable_keys(model)"},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_keys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get all unique names of the model variables — variable_keys","text":"model model","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_keys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get all unique names of the model variables — variable_keys","text":"character vector ordered way         constraint matrix columns objective vector","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_keys.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get all unique names of the model variables — variable_keys","text":"","code":"library(magrittr) model <- MIPModel() %>%   add_variable(x[i], i = 1:3) variable_keys(model) #> [1] \"x[1]\" \"x[2]\" \"x[3]\""},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_types.html","id":null,"dir":"Reference","previous_headings":"","what":"Variable types of a model — variable_types","title":"Variable types of a model — variable_types","text":"One component variable correct order","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_types.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variable types of a model — variable_types","text":"","code":"variable_types(model)"},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_types.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variable types of a model — variable_types","text":"model model","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_types.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variable types of a model — variable_types","text":"factor levels binary, continuous, integer","code":""},{"path":"https://dirkschumacher.github.io/ompr/reference/variable_types.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Variable types of a model — variable_types","text":"","code":"library(magrittr) model <- MIPModel() %>%   add_variable(x, type = \"binary\") %>%   add_variable(y, type = \"continuous\") %>%   add_variable(z, type = \"integer\") variable_types(model) #> [1] binary     continuous integer    #> Levels: binary continuous integer"},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"ompr-101","dir":"Changelog","previous_headings":"","what":"ompr 1.0.1","title":"ompr 1.0.1","text":"CRAN release: 2022-01-26","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"bugfixes-1-0-1","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"ompr 1.0.1","text":"additional_solver_output() now exported function.","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"ompr-100","dir":"Changelog","previous_headings":"","what":"ompr 1.0.0","title":"ompr 1.0.0","text":"CRAN release: 2022-01-26","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"general-changes-1-0-0","dir":"Changelog","previous_headings":"","what":"General changes","title":"ompr 1.0.0","text":"Rewrote MIPModel. now faster, maintainable, stable fewer bugs. Added sum_over, replacement sum_expr MIPModel set_bounds MIPModel now accepts ()equalities well (#365) MIPModel now supports characters variable indexes solution object new named entry called additional_solver_output. place solver packages, like ompr.roi can store arbitrary solver information. Including solver specific messages status codes. read using function additional_solver_output(). solution can now solver_status = \"success\" used recent ompr.roi version.","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"bugfixes-1-0-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"ompr 1.0.0","text":"Fixed bug using index “e” sum_expr failed (#327) Fixed bug coefficients came variable expression sometimes correctly parsed (#265) Fixed bug add_variable failed indexes wrong order (#266)","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"deprecations-1-0-0","dir":"Changelog","previous_headings":"","what":"Deprecations","title":"ompr 1.0.0","text":"listed functions likely removed later point future. sum_expr shall used anymore. Please use sum_over instead. MIPLModel likely removed package, vectorized approach lead problems. Please use MIPModel instead. add_variable_, add_constraint_, set_objective_, set_bounds get_solution_ needed anymore new MIPModel powered rlang. .show_progress_bar parameter now deprecated functions.","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"licensing-1-0-0","dir":"Changelog","previous_headings":"","what":"Licensing","title":"ompr 1.0.0","text":"ompr now licensed MIT license (#353).","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"breaking-changes-1-0-0","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"ompr 1.0.0","text":"extract_constraints now always returns sparse matrix, even 0 constraints variables. row ordering data.frame returned get_solution(x[, j]) slightly changed special cases, majority calls, stay . One special cases created variable similar add_variable(model, x[, j], j = ..., = ...), indexes variable quantifiers different orderings. general, please depend ordering rows, use indexes retrieve correct value. example sorting data.frame , reading.","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"ompr-081","dir":"Changelog","previous_headings":"","what":"ompr 0.8.1","title":"ompr 0.8.1","text":"CRAN release: 2020-12-04","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"general-changes-0-8-1","dir":"Changelog","previous_headings":"","what":"General changes","title":"ompr 0.8.1","text":"can now assign coefficients column/row combinations using colwise experimental MILPModel backend. Non-existent indexes sum_expr now produce warning instead error. missing indexes ignored (#202).","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"bugfixes-0-8-1","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"ompr 0.8.1","text":"Fixed bug get_solution return mixed values variables partially similar names (eg: s[] bus[]) @hugolarzabal (#244). Fixed bug -condition input length != 1. Fixed minor issues newer data.table versions","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"ompr-080","dir":"Changelog","previous_headings":"","what":"ompr 0.8.0","title":"ompr 0.8.0","text":"CRAN release: 2018-06-11","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"general-changes-0-8-0","dir":"Changelog","previous_headings":"","what":"General changes","title":"ompr 0.8.0","text":"Removed dplyr dependency Added MILPModel, new, vectorized backend mixed integer linear programs can handle large models. eventually replace MIPModel. Added two functions (get_column_duals, get_row_duals) extract dual (column row) values LP. minimum supported R version now 3.2.0 get_solution now always return solution, even solution status optimal. get_solution third argument type permitted values “primal” “dual” return respective column primal dual values.","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"bugfixes-0-8-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"ompr 0.8.0","text":"can now extract solutions indexed variables length one (#198)","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"ompr-070","dir":"Changelog","previous_headings":"","what":"ompr 0.7.0","title":"ompr 0.7.0","text":"CRAN release: 2017-11-17","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"breaking-changes-0-7-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"ompr 0.7.0","text":"ompr now uses sparse constraint matrices. extract_constraints now returns sparse matrix objective_function returns sparse vector. minimum supported R version now 3.3.0 Fixed issue Rcpp. minimum Rcpp version now 0.12.12","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"minor-changes-0-7-0","dir":"Changelog","previous_headings":"","what":"Minor changes","title":"ompr 0.7.0","text":"New progress bar based progress package.","code":""},{"path":"https://dirkschumacher.github.io/ompr/news/index.html","id":"ompr-060","dir":"Changelog","previous_headings":"","what":"ompr 0.6.0","title":"ompr 0.6.0","text":"CRAN release: 2017-04-17 First version CRAN","code":""}]
